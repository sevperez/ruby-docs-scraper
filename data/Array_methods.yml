---
:id: 2
:name: Array
:link: http://ruby-doc.org/core-2.4.1/Array.html
:methods:
- :id: 0
  :callseqs:
  - "[](*args)"
  :description:
  - Returns a new array populated with the given objects.
  :examples: |
    Array.[]( 1, 'a', /^A/ ) # => [1, "a", /^A/]
    Array[ 1, 'a', /^A/ ]    # => [1, "a", /^A/]
    [ 1, 'a', /^A/ ]         # => [1, "a", /^A/]
- :id: 1
  :callseqs:
  - new(size=0, default=nil)
  - new(array)
  - new(size) {|index| block }
  :description:
  - Returns a new array.
  - "In the first form, if no arguments are sent, the new array will be empty.\nWhen
    a size and an optional default are sent, an\narray is created with size copies
    of default. \nTake notice that all elements will reference the same object\ndefault."
  - |-
    The second form creates a copy of the array passed as a parameter (the
    array is generated by calling #to_ary on the parameter).
  - |-
    In the last form, an array of the given size is created.  Each element in
    this array is created by passing the element’s index to the given block and
    storing the return value.
  - |-
    When sending the second parameter, the same object will be used as the
    value for all the array elements:
  - |-
    Since all the Array elements store the same hash,
    changes to one of them will affect them all.
  - |-
    If multiple copies are what you want, you should use the block version
    which uses the result of that block each time an element of the array needs
    to be initialized:
  :examples: |
    first_array = ["Matz", "Guido"]

    second_array = Array.new(first_array) #=> ["Matz", "Guido"]

    first_array.equal? second_array       #=> false
    Array.new(3){ |index| index ** 2 }
    # => [0, 1, 4]
    a = Array.new(2, Hash.new)
    # => [{}, {}]

    a[0]['cat'] = 'feline'
    a # => [{"cat"=>"feline"}, {"cat"=>"feline"}]

    a[1]['cat'] = 'Felix'
    a # => [{"cat"=>"Felix"}, {"cat"=>"Felix"}]
    a = Array.new(2) { Hash.new }
    a[0]['cat'] = 'feline'
    a # => [{"cat"=>"feline"}, {}]
- :id: 2
  :callseqs:
  - try_convert(obj) → array or nil
  :description:
  - |-
    Tries to convert obj into an array, using to_ary
    method.  Returns the converted array or nil if
    obj cannot be converted for any reason. This method can be
    used to check if an argument is an array.
  :examples: |
    Array.try_convert([1])   #=> [1]
    Array.try_convert("1")   #=> nil

    if tmp = Array.try_convert(arg)
      # the argument is an array
    elsif tmp = String.try_convert(arg)
      # the argument is a string
    end
- :id: 3
  :callseqs:
  - ary & other_ary      → new_ary
  :description:
  - |-
    Set Intersection — Returns a new array containing unique elements common to
    the two arrays. The order is preserved from the original array.
  - It compares elements using their hash and eql? methods for efficiency.
  - 'See also #uniq.'
  :examples: |
    [ 1, 1, 3, 5 ] & [ 3, 2, 1 ]                 #=> [ 1, 3 ]
    [ 'a', 'b', 'b', 'z' ] & [ 'a', 'b', 'c' ]   #=> [ 'a', 'b' ]
- :id: 4
  :callseqs:
  - ary * int     → new_ary
  - ary * str     → new_string
  :description:
  - |-
    Repetition — With a String argument, equivalent
    to ary.join(str).
  - |-
    Otherwise, returns a new array built by concatenating the int
    copies of self.
  :examples: |
    [ 1, 2, 3 ] * 3    #=> [ 1, 2, 3, 1, 2, 3, 1, 2, 3 ]
    [ 1, 2, 3 ] * ","  #=> "1,2,3"
- :id: 5
  :callseqs:
  - ary + other_ary   → new_ary
  :description:
  - |-
    Concatenation — Returns a new array built by concatenating the two arrays
    together to produce a third array.
  - Note that
  - is the same as
  - |-
    This means that it produces a new array. As a consequence, repeated use of
    += on arrays can be quite inefficient.
  - 'See also #concat.'
  :examples: |
    [ 1, 2, 3 ] + [ 4, 5 ]    #=> [ 1, 2, 3, 4, 5 ]
    a = [ "a", "b", "c" ]
    c = a + [ "d", "e", "f" ]
    c                         #=> [ "a", "b", "c", "d", "e", "f" ]
    a                         #=> [ "a", "b", "c" ]
    x += y
    x = x + y
- :id: 6
  :callseqs:
  - ary - other_ary    → new_ary
  :description:
  - Array Difference
  - |-
    Returns a new array that is a copy of the original array, removing any
    items that also appear in other_ary. The order is preserved
    from the original array.
  - It compares elements using their hash and eql? methods for efficiency.
  - If you need set-like behavior, see the library class Set.
  :examples: "[ 1, 1, 2, 2, 3, 3, 4, 5 ] - [ 1, 2, 4 ]  #=>  [ 3, 3, 5 ]\n"
- :id: 7
  :callseqs:
  - ary << obj            → ary
  :description:
  - |-
    Append—Pushes the given object on to the end of this array. This expression
    returns the array itself, so several appends may be chained together.
  :examples: |
    [ 1, 2 ] << "c" << "d" << [ 3, 4 ]
            #=>  [ 1, 2, "c", "d", [ 3, 4 ] ]
- :id: 8
  :callseqs:
  - ary <=> other_ary   →  -1, 0, +1 or nil
  :description:
  - |-
    Comparison — Returns an integer (-1, 0, or
    +1) if this array is less than, equal to, or greater than
    other_ary.
  - Each object in each array is compared (using the <=> operator).
  - |-
    Arrays are compared in an “element-wise” manner; the first element of
    ary is compared with the first one of other_ary
    using the <=> operator, then each of the second elements, etc… As
    soon as the result of any such comparison is non zero (i.e. the two
    corresponding elements are not equal), that result is returned for the
    whole array comparison.
  - |-
    If all the elements are equal, then the result is based on a comparison of
    the array lengths. Thus, two arrays are “equal” according to
    Array#<=> if, and only if, they have the same length and the value of
    each element is equal to the value of the corresponding element in the
    other array.
  - |-
    nil is returned if the other_ary is not an array
    or if the comparison of two elements returned nil.
  :examples: |
    [ "a", "a", "c" ]    <=> [ "a", "b", "c" ]   #=> -1
    [ 1, 2, 3, 4, 5, 6 ] <=> [ 1, 2 ]            #=> +1
    [ 1, 2 ]             <=> [ 1, :two ]         #=> nil
- :id: 9
  :callseqs:
  - ary == other_ary   →   bool
  :description:
  - |-
    Equality — Two arrays are equal if they contain the same number of elements
    and if each element is equal to (according to Object#==) the corresponding
    element in other_ary.
  :examples: |
    [ "a", "c" ]    == [ "a", "c", 7 ]     #=> false
    [ "a", "c", 7 ] == [ "a", "c", 7 ]     #=> true
    [ "a", "c", 7 ] == [ "a", "d", "f" ]   #=> false
- :id: 10
  :callseqs:
  - ary[index]                → obj     or nil
  - ary[start, length]        → new_ary or nil
  - ary[range]                → new_ary or nil
  - slice(index)          → obj     or nil
  - slice(start, length)  → new_ary or nil
  - slice(range)          → new_ary or nil
  :description:
  - |-
    Element Reference — Returns the element at index, or returns a
    subarray starting at the start index and continuing for
    length elements, or returns a subarray specified by
    range of indices.
  - |-
    Negative indices count backward from the end of the array (-1 is the last
    element).  For start and range cases the starting
    index is just before an element.  Additionally, an empty array is returned
    when the starting index for an element range is at the end of the array.
  - Returns nil if the index (or starting index) are out of range.
  :examples: |
    a = [ "a", "b", "c", "d", "e" ]
    a[2] +  a[0] + a[1]    #=> "cab"
    a[6]                   #=> nil
    a[1, 2]                #=> [ "b", "c" ]
    a[1..3]                #=> [ "b", "c", "d" ]
    a[4..7]                #=> [ "e" ]
    a[6..10]               #=> nil
    a[-3, 3]               #=> [ "c", "d", "e" ]
    # special cases
    a[5]                   #=> nil
    a[6, 1]                #=> nil
    a[5, 1]                #=> []
    a[5..10]               #=> []
- :id: 11
  :callseqs:
  - ary[index]         = obj                      →  obj
  - ary[start, length] = obj or other_ary or nil  →  obj or other_ary or nil
  - ary[range]         = obj or other_ary or nil  →  obj or other_ary or nil
  :description:
  - |-
    Element Assignment — Sets the element at index, or replaces a
    subarray from the start index for length
    elements, or replaces a subarray specified by the range of
    indices.
  - |-
    If indices are greater than the current capacity of the array, the array
    grows automatically.  Elements are inserted into the array at
    start if length is zero.
  - |-
    Negative indices will count backward from the end of the array.  For
    start and range cases the starting index is just
    before an element.
  - |-
    An IndexError is raised if a negative index
    points past the beginning of the array.
  - 'See also #push, and #unshift.'
  :examples: |
    a = Array.new
    a[4] = "4";                 #=> [nil, nil, nil, nil, "4"]
    a[0, 3] = [ 'a', 'b', 'c' ] #=> ["a", "b", "c", nil, "4"]
    a[1..2] = [ 1, 2 ]          #=> ["a", 1, 2, nil, "4"]
    a[0, 2] = "?"               #=> ["?", 2, nil, "4"]
    a[0..2] = "A"               #=> ["A", "4"]
    a[-1]   = "Z"               #=> ["A", "Z"]
    a[1..-1] = nil              #=> ["A", nil]
    a[1..-1] = []               #=> ["A"]
    a[0, 0] = [ 1, 2 ]          #=> [1, 2, "A"]
    a[3, 0] = "B"               #=> [1, 2, "A", "B"]
- :id: 12
  :callseqs:
  - any? [{ |obj| block }]   → true or false
  :description:
  - See also Enumerable#any?
  :examples: ''
- :id: 13
  :callseqs:
  - append(*args)
  :description: []
  :examples: ''
- :id: 14
  :callseqs:
  - assoc(obj)   → element_ary  or  nil
  :description:
  - |-
    Searches through an array whose elements are also arrays comparing
    obj with the first element of each contained array using
    obj.==.
  - |-
    Returns the first contained array that matches (that is, the first
    associated array), or nil if no match is found.
  - 'See also #rassoc'
  :examples: |
    s1 = [ "colors", "red", "blue", "green" ]
    s2 = [ "letters", "a", "b", "c" ]
    s3 = "foo"
    a  = [ s1, s2, s3 ]
    a.assoc("letters")  #=> [ "letters", "a", "b", "c" ]
    a.assoc("foo")      #=> nil
- :id: 15
  :callseqs:
  - at(index)   →   obj  or nil
  :description:
  - |-
    Returns the element at index. A negative index counts from the
    end of self. Returns nil if the index is out of
    range. See also #[].
  :examples: |
    a = [ "a", "b", "c", "d", "e" ]
    a.at(0)     #=> "a"
    a.at(-1)    #=> "e"
- :id: 16
  :callseqs:
  - bsearch {|x| block }  → elem
  :description:
  - |-
    By using binary search, finds a value from this array which meets the given
    condition in O(log n) where n is the size of the array.
  - |-
    You can use this method in two use cases: a find-minimum mode and a
    find-any mode.  In either case, the elements of the array must be monotone
    (or sorted) with respect to the block.
  - |-
    In find-minimum mode (this is a good choice for typical use case), the
    block must return true or false, and there must be an index i (0 <= i
    <= ary.size) so that:
  - the block returns false for any element whose index is less than i, and
  - |-
    the block returns true for any element whose index is greater than or equal
    to i.
  - |-
    This method returns the i-th element.  If i is equal to ary.size, it
    returns nil.
  - |-
    In find-any mode (this behaves like libc’s bsearch(3)), the block must
    return a number, and there must be two indices i and j (0 <= i <= j
    <= ary.size) so that:
  - |-
    the block returns a positive number for ary if 0 <= k
    < i,
  - the block returns zero for ary if i <= k < j, and
  - |-
    the block returns a negative number for ary if j <= k
    < ary.size.
  - |-
    Under this condition, this method returns any element whose index is within
    i…j.  If i is equal to j (i.e., there is no element that satisfies the
    block), this method returns nil.
  - |-
    You must not mix the two modes at a time; the block must always return
    either true/false, or always return a number.  It is undefined which value
    is actually picked up at each iteration.
  :examples: |
    ary = [0, 4, 7, 10, 12]
    ary.bsearch {|x| x >=   4 } #=> 4
    ary.bsearch {|x| x >=   6 } #=> 7
    ary.bsearch {|x| x >=  -1 } #=> 0
    ary.bsearch {|x| x >= 100 } #=> nil
    ary = [0, 4, 7, 10, 12]
    # try to find v such that 4 <= v < 8
    ary.bsearch {|x| 1 - x / 4 } #=> 4 or 7
    # try to find v such that 8 <= v < 10
    ary.bsearch {|x| 4 - x / 2 } #=> nil
- :id: 17
  :callseqs:
  - bsearch_index {|x| block }  → int or nil
  :description:
  - |-
    By using binary search, finds an index of a value from this array which
    meets the given condition in O(log n) where n is the size of the array.
  - |-
    It supports two modes, depending on the nature of the block and they are
    exactly the same as in the case of bsearch method with the only
    difference being that this method returns the index of the element instead
    of the element itself. For more details consult the documentation for bsearch.
  :examples: ''
- :id: 18
  :callseqs:
  - clear    → ary
  :description:
  - Removes all elements from self.
  :examples: |
    a = [ "a", "b", "c", "d", "e" ]
    a.clear    #=> [ ]
- :id: 19
  :callseqs:
  - collect { |item| block }  → new_ary
  - collect                   → Enumerator
  :description:
  - Invokes the given block once for each element of self.
  - Creates a new array containing the values returned by the block.
  - See also Enumerable#collect.
  - |-
    If no block is given, an Enumerator is
    returned instead.
  :examples: |
    a = [ "a", "b", "c", "d" ]
    a.collect { |x| x + "!" }         #=> ["a!", "b!", "c!", "d!"]
    a.map.with_index { |x, i| x * i } #=> ["", "b", "cc", "ddd"]
    a                                 #=> ["a", "b", "c", "d"]
- :id: 20
  :callseqs:
  - collect! {|item| block }   → ary
  - collect!                   → Enumerator
  :description:
  - |-
    Invokes the given block once for each element of self,
    replacing the element with the value returned by the block.
  - See also Enumerable#collect.
  - |-
    If no block is given, an Enumerator is
    returned instead.
  :examples: |
    a = [ "a", "b", "c", "d" ]
    a.map! {|x| x + "!" }
    a #=>  [ "a!", "b!", "c!", "d!" ]
    a.collect!.with_index {|x, i| x[0...i] }
    a #=>  ["", "b", "c!", "d!"]
- :id: 21
  :callseqs:
  - combination(n) { |c| block }    → ary
  - combination(n)                  → Enumerator
  :description:
  - |-
    When invoked with a block, yields all combinations of length n
    of elements from the array and then returns the array itself.
  - |-
    The implementation makes no guarantees about the order in which the
    combinations are yielded.
  - |-
    If no block is given, an Enumerator is
    returned instead.
  - 'Examples:'
  :examples: |
    a = [1, 2, 3, 4]
    a.combination(1).to_a  #=> [[1],[2],[3],[4]]
    a.combination(2).to_a  #=> [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
    a.combination(3).to_a  #=> [[1,2,3],[1,2,4],[1,3,4],[2,3,4]]
    a.combination(4).to_a  #=> [[1,2,3,4]]
    a.combination(0).to_a  #=> [[]] # one combination of length 0
    a.combination(5).to_a  #=> []   # no combinations of length 5
- :id: 22
  :callseqs:
  - compact     → new_ary
  :description:
  - |-
    Returns a copy of self with all nil elements
    removed.
  :examples: |
    [ "a", nil, "b", nil, "c", nil ].compact
                      #=> [ "a", "b", "c" ]
- :id: 23
  :callseqs:
  - compact!    → ary  or  nil
  :description:
  - Removes nil elements from the array.
  - |-
    Returns nil if no changes were made, otherwise returns the
    array.
  :examples: |
    [ "a", nil, "b", nil, "c" ].compact! #=> [ "a", "b", "c" ]
    [ "a", "b", "c" ].compact!           #=> nil
- :id: 24
  :callseqs:
  - concat(other_ary1, other_ary2,...)   → ary
  :description:
  - Appends the elements of +other_ary+s to self.
  - See also Array#+.
  :examples: |
    [ "a", "b" ].concat( ["c", "d"] ) #=> [ "a", "b", "c", "d" ]
    [ "a" ].concat( ["b"], ["c", "d"] ) #=> [ "a", "b", "c", "d" ]
    [ "a" ].concat #=> [ "a" ]

    a = [ 1, 2, 3 ]
    a.concat( [ 4, 5 ] )
    a                                 #=> [ 1, 2, 3, 4, 5 ]

    a = [ 1, 2 ]
    a.concat(a, a)                    #=> [1, 2, 1, 2, 1, 2]
- :id: 25
  :callseqs:
  - count                   → int
  - count(obj)              → int
  - count { |item| block }  → int
  :description:
  - Returns the number of elements.
  - |-
    If an argument is given, counts the number of elements which equal
    obj using ==.
  - |-
    If a block is given, counts the number of elements for which the block
    returns a true value.
  :examples: |
    ary = [1, 2, 4, 2]
    ary.count                  #=> 4
    ary.count(2)               #=> 2
    ary.count { |x| x%2 == 0 } #=> 3
- :id: 26
  :callseqs:
  - cycle(n=nil) { |obj| block }  → nil
  - cycle(n=nil)                  → Enumerator
  :description:
  - |-
    Calls the given block for each element n times or forever if
    nil is given.
  - Does nothing if a non-positive number is given or the array is empty.
  - |-
    Returns nil if the loop has finished without getting
    interrupted.
  - |-
    If no block is given, an Enumerator is
    returned instead.
  :examples: |
    a = ["a", "b", "c"]
    a.cycle { |x| puts x }     # print, a, b, c, a, b, c,.. forever.
    a.cycle(2) { |x| puts x }  # print, a, b, c, a, b, c.
- :id: 27
  :callseqs:
  - delete(obj)            → item or nil
  - delete(obj) { block }  → item or result of block
  :description:
  - |-
    Deletes all items from self that are equal to
    obj.
  - |-
    Returns the last deleted item, or nil if no matching item is
    found.
  - |-
    If the optional code block is given, the result of the block is returned if
    the item is not found.  (To remove nil elements and get an
    informative return value, use #compact!)
  :examples: |
    a = [ "a", "b", "b", "b", "c" ]
    a.delete("b")                   #=> "b"
    a                               #=> ["a", "c"]
    a.delete("z")                   #=> nil
    a.delete("z") { "not found" }   #=> "not found"
- :id: 28
  :callseqs:
  - delete_at(index)  → obj or nil
  :description:
  - |-
    Deletes the element at the specified index, returning that
    element, or nil if the index is out of range.
  - 'See also #slice!'
  :examples: |
    a = ["ant", "bat", "cat", "dog"]
    a.delete_at(2)    #=> "cat"
    a                 #=> ["ant", "bat", "dog"]
    a.delete_at(99)   #=> nil
- :id: 29
  :callseqs:
  - delete_if { |item| block }  → ary
  - delete_if                   → Enumerator
  :description:
  - |-
    Deletes every element of self for which block evaluates to
    true.
  - |-
    The array is changed instantly every time the block is called, not after
    the iteration is over.
  - 'See also #reject!'
  - |-
    If no block is given, an Enumerator is
    returned instead.
  :examples: |
    scores = [ 97, 42, 75 ]
    scores.delete_if {|score| score < 80 }   #=> [97]
- :id: 30
  :callseqs:
  - dig(idx, ...)                 → object
  :description:
  - |-
    Extracts the nested value specified by the sequence of idx objects
    by calling dig at each step, returning nil if any
    intermediate step is nil.
  :examples: |
    a = [[1, [2, 3]]]

    a.dig(0, 1, 1)                    #=> 3
    a.dig(1, 2, 3)                    #=> nil
    a.dig(0, 0, 0)                    #=> TypeError: Integer does not have #dig method
    [42, {foo: :bar}].dig(1, :foo)    #=> :bar
- :id: 31
  :callseqs:
  - drop(n)               → new_ary
  :description:
  - |-
    Drops first n elements from ary and returns the
    rest of the elements in an array.
  - If a negative number is given, raises an ArgumentError.
  - 'See also #take'
  :examples: |
    a = [1, 2, 3, 4, 5, 0]
    a.drop(3)             #=> [4, 5, 0]
- :id: 32
  :callseqs:
  - drop_while { |obj| block }   → new_ary
  - drop_while                  → Enumerator
  :description:
  - |-
    Drops elements up to, but not including, the first element for which the
    block returns nil or false and returns an array
    containing the remaining elements.
  - |-
    If no block is given, an Enumerator is
    returned instead.
  - 'See also #take_while'
  :examples: |
    a = [1, 2, 3, 4, 5, 0]
    a.drop_while {|i| i < 3 }   #=> [3, 4, 5, 0]
- :id: 33
  :callseqs:
  - each { |item| block }  → ary
  - each                   → Enumerator
  :description:
  - |-
    Calls the given block once for each element in self, passing
    that element as a parameter.  Returns the array itself.
  - |-
    If no block is given, an Enumerator is
    returned.
  - 'produces:'
  :examples: |
    a = [ "a", "b", "c" ]
    a.each {|x| print x, " -- " }
- :id: 34
  :callseqs:
  - each_index { |index| block }  → ary
  - each_index                    → Enumerator
  :description:
  - |-
    Same as #each, but passes the
    index of the element instead of the element itself.
  - |-
    An Enumerator is returned if no block is
    given.
  - 'produces:'
  :examples: |
    a = [ "a", "b", "c" ]
    a.each_index {|x| print x, " -- " }
- :id: 35
  :callseqs:
  - empty?   → true or false
  :description:
  - Returns true if self contains no elements.
  :examples: "[].empty?   #=> true\n"
- :id: 36
  :callseqs:
  - eql?(other)  → true or false
  :description:
  - |-
    Returns true if self and other are
    the same object, or are both arrays with the same content (according to Object#eql?).
  :examples: ''
- :id: 37
  :callseqs:
  - fetch(index)                    → obj
  - fetch(index, default)           → obj
  - fetch(index) { |index| block }  → obj
  :description:
  - |-
    Tries to return the element at position index, but throws an
    IndexError exception if the referenced
    index lies outside of the array bounds.  This error can be
    prevented by supplying a second argument, which will act as a
    default value.
  - |-
    Alternatively, if a block is given it will only be executed when an invalid
    index is referenced.
  - Negative values of index count from the end of the array.
  :examples: |
    a = [ 11, 22, 33, 44 ]
    a.fetch(1)               #=> 22
    a.fetch(-1)              #=> 44
    a.fetch(4, 'cat')        #=> "cat"
    a.fetch(100) { |i| puts "#{i} is out of bounds" }
                             #=> "100 is out of bounds"
- :id: 38
  :callseqs:
  - fill(obj)                                 → ary
  - fill(obj, start [, length])               → ary
  - fill(obj, range )                         → ary
  - fill { |index| block }                    → ary
  - fill(start [, length] ) { |index| block } → ary
  - fill(range) { |index| block }             → ary
  :description:
  - |-
    The first three forms set the selected elements of self (which
    may be the entire array) to obj.
  - A start of nil is equivalent to zero.
  - |-
    A length of nil is equivalent to the length of
    the array.
  - |-
    The last three forms fill the array with the value of the given block,
    which is passed the absolute index of each element to be filled.
  - |-
    Negative values of start count from the end of the array,
    where -1 is the last element.
  :examples: |
    a = [ "a", "b", "c", "d" ]
    a.fill("x")              #=> ["x", "x", "x", "x"]
    a.fill("z", 2, 2)        #=> ["x", "x", "z", "z"]
    a.fill("y", 0..1)        #=> ["y", "y", "z", "z"]
    a.fill { |i| i*i }       #=> [0, 1, 4, 9]
    a.fill(-2) { |i| i*i*i } #=> [0, 1, 8, 27]
- :id: 39
  :callseqs:
  - find_index(obj)             →  int or nil
  - find_index { |item| block } →  int or nil
  - find_index                  →  Enumerator
  :description:
  - |-
    Returns the index of the first object in ary such
    that the object is == to obj.
  - |-
    If a block is given instead of an argument, returns the index of
    the first object for which the block returns true.  Returns
    nil if no match is found.
  - 'See also #rindex.'
  - |-
    An Enumerator is returned if neither a block
    nor argument is given.
  :examples: |
    a = [ "a", "b", "c" ]
    a.index("b")              #=> 1
    a.index("z")              #=> nil
    a.index { |x| x == "b" }  #=> 1
- :id: 40
  :callseqs:
  - first     →   obj or nil
  - first(n)  →   new_ary
  :description:
  - |-
    Returns the first element, or the first n elements, of the
    array. If the array is empty, the first form returns nil, and
    the second form returns an empty array. See also #last for the opposite effect.
  :examples: |
    a = [ "q", "r", "s", "t" ]
    a.first     #=> "q"
    a.first(2)  #=> ["q", "r"]
- :id: 41
  :callseqs:
  - flatten → new_ary
  - flatten(level) → new_ary
  :description:
  - |-
    Returns a new array that is a one-dimensional flattening of
    self (recursively).
  - |-
    That is, for every element that is an array, extract its elements into the
    new array.
  - |-
    The optional level argument determines the level of recursion
    to flatten.
  :examples: |
    s = [ 1, 2, 3 ]           #=> [1, 2, 3]
    t = [ 4, 5, 6, [7, 8] ]   #=> [4, 5, 6, [7, 8]]
    a = [ s, t, 9, 10 ]       #=> [[1, 2, 3], [4, 5, 6, [7, 8]], 9, 10]
    a.flatten                 #=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    a = [ 1, 2, [3, [4, 5] ] ]
    a.flatten(1)              #=> [1, 2, 3, [4, 5]]
- :id: 42
  :callseqs:
  - flatten!        → ary or nil
  - flatten!(level) → ary or nil
  :description:
  - Flattens self in place.
  - |-
    Returns nil if no modifications were made (i.e., the array
    contains no subarrays.)
  - |-
    The optional level argument determines the level of recursion
    to flatten.
  :examples: |
    a = [ 1, 2, [3, [4, 5] ] ]
    a.flatten!   #=> [1, 2, 3, 4, 5]
    a.flatten!   #=> nil
    a            #=> [1, 2, 3, 4, 5]
    a = [ 1, 2, [3, [4, 5] ] ]
    a.flatten!(1) #=> [1, 2, 3, [4, 5]]
- :id: 43
  :callseqs:
  - frozen?  → true or false
  :description:
  - |-
    Return true if this array is frozen (or temporarily frozen
    while being sorted). See also Object#frozen?
  :examples: ''
- :id: 44
  :callseqs:
  - hash   → integer
  :description:
  - Compute a hash-code for this array.
  - |-
    Two arrays with the same content will have the same hash code (and will
    compare using eql?).
  - See also Object#hash.
  :examples: ''
- :id: 45
  :callseqs:
  - include?(object)   → true or false
  :description:
  - |-
    Returns true if the given object is present in
    self (that is, if any element ==
    object), otherwise returns false.
  :examples: |
    a = [ "a", "b", "c" ]
    a.include?("b")   #=> true
    a.include?("z")   #=> false
- :id: 46
  :callseqs:
  - index(obj)             →  int or nil
  - index { |item| block } →  int or nil
  - index                  →  Enumerator
  :description:
  - |-
    Returns the index of the first object in ary such
    that the object is == to obj.
  - |-
    If a block is given instead of an argument, returns the index of
    the first object for which the block returns true.  Returns
    nil if no match is found.
  - 'See also #rindex.'
  - |-
    An Enumerator is returned if neither a block
    nor argument is given.
  :examples: |
    a = [ "a", "b", "c" ]
    a.index("b")              #=> 1
    a.index("z")              #=> nil
    a.index { |x| x == "b" }  #=> 1
- :id: 47
  :callseqs:
  - initialize_copy(other_ary)   → ary
  :description:
  - |-
    Replaces the contents of self with the contents of
    other_ary, truncating or expanding if necessary.
  :examples: |
    a = [ "a", "b", "c", "d", "e" ]
    a.replace([ "x", "y", "z" ])   #=> ["x", "y", "z"]
    a                              #=> ["x", "y", "z"]
- :id: 48
  :callseqs:
  - insert(index, obj...)  → ary
  :description:
  - |-
    Inserts the given values before the element with the given
    index.
  - |-
    Negative indices count backwards from the end of the array, where
    -1 is the last element. If a negative index is used, the given
    values will be inserted after that element, so using an index of
    -1 will insert the values at the end of the array.
  :examples: |
    a = %w{ a b c d }
    a.insert(2, 99)         #=> ["a", "b", 99, "c", "d"]
    a.insert(-2, 1, 2, 3)   #=> ["a", "b", 99, "c", 1, 2, 3, "d"]
- :id: 49
  :callseqs:
  - inspect  → string
  - to_s     → string
  :description:
  - Creates a string representation of self.
  :examples: '[ "a", "b", "c" ].to_s     #=> "[\"a\", \"b\", \"c\"]"

'
- :id: 50
  :callseqs:
  - join(separator=$,)    → str
  :description:
  - |-
    Returns a string created by converting each element of the array to a
    string, separated by the given separator. If the
    separator is nil, it uses current
    $,. If both the separator and $, are
    nil, it uses an empty string.
  - 'For nested arrays, join is applied recursively:'
  :examples: |
    [ "a", "b", "c" ].join        #=> "abc"
    [ "a", "b", "c" ].join("-")   #=> "a-b-c"
    [ "a", [1, 2, [:x, :y]], "b" ].join("-")   #=> "a-1-2-x-y-b"
- :id: 51
  :callseqs:
  - keep_if { |item| block } → ary
  - keep_if                  → Enumerator
  :description:
  - |-
    Deletes every element of self for which the given block
    evaluates to false.
  - 'See also #select!'
  - |-
    If no block is given, an Enumerator is
    returned instead.
  :examples: |
    a = %w{ a b c d e f }
    a.keep_if { |v| v =~ /[aeiou]/ }  #=> ["a", "e"]
- :id: 52
  :callseqs:
  - last     →  obj or nil
  - last(n)  →  new_ary
  :description:
  - |-
    Returns the last element(s) of self. If the array is empty,
    the first form returns nil.
  - |-
    See also #first for the opposite
    effect.
  :examples: |
    a = [ "w", "x", "y", "z" ]
    a.last     #=> "z"
    a.last(2)  #=> ["y", "z"]
- :id: 53
  :callseqs:
  - length → int
  :description:
  - Returns the number of elements in self. May be zero.
  :examples: |
    [ 1, 2, 3, 4, 5 ].length   #=> 5
    [].length                  #=> 0
- :id: 54
  :callseqs:
  - map     { |item| block }  → new_ary
  - map                       → Enumerator
  :description:
  - Invokes the given block once for each element of self.
  - Creates a new array containing the values returned by the block.
  - See also Enumerable#collect.
  - |-
    If no block is given, an Enumerator is
    returned instead.
  :examples: |
    a = [ "a", "b", "c", "d" ]
    a.collect { |x| x + "!" }         #=> ["a!", "b!", "c!", "d!"]
    a.map.with_index { |x, i| x * i } #=> ["", "b", "cc", "ddd"]
    a                                 #=> ["a", "b", "c", "d"]
- :id: 55
  :callseqs:
  - map!     {|item| block }   → ary
  - map!                       → Enumerator
  :description:
  - |-
    Invokes the given block once for each element of self,
    replacing the element with the value returned by the block.
  - See also Enumerable#collect.
  - |-
    If no block is given, an Enumerator is
    returned instead.
  :examples: |
    a = [ "a", "b", "c", "d" ]
    a.map! {|x| x + "!" }
    a #=>  [ "a!", "b!", "c!", "d!" ]
    a.collect!.with_index {|x, i| x[0...i] }
    a #=>  ["", "b", "c!", "d!"]
- :id: 56
  :callseqs:
  - max                     → obj
  - max { |a, b| block }    → obj
  - max(n)                  → array
  - max(n) { |a, b| block } → array
  :description:
  - |-
    Returns the object in ary with the maximum value. The first form
    assumes all objects implement Comparable; the second uses the
    block to return a <=> b.
  - |-
    If the n argument is given, maximum n elements
    are returned as an array.
  :examples: |
    a = %w(albatross dog horse)
    a.max                                   #=> "horse"
    a.max { |a, b| a.length <=> b.length }  #=> "albatross"
    a = %w[albatross dog horse]
    a.max(2)                                  #=> ["horse", "dog"]
    a.max(2) {|a, b| a.length <=> b.length }  #=> ["albatross", "horse"]
- :id: 57
  :callseqs:
  - min                     → obj
  - min {| a,b | block }    → obj
  - min(n)                  → array
  - min(n) {| a,b | block } → array
  :description:
  - |-
    Returns the object in ary with the minimum value. The first form
    assumes all objects implement Comparable; the second uses the
    block to return a <=> b.
  - |-
    If the n argument is given, minimum n elements
    are returned as an array.
  :examples: |
    a = %w(albatross dog horse)
    a.min                                   #=> "albatross"
    a.min { |a, b| a.length <=> b.length }  #=> "dog"
    a = %w[albatross dog horse]
    a.min(2)                                  #=> ["albatross", "dog"]
    a.min(2) {|a, b| a.length <=> b.length }  #=> ["dog", "horse"]
- :id: 58
  :callseqs:
  - pack( aTemplateString ) → aBinaryString
  - 'pack( aTemplateString, buffer: aBufferString ) → aBufferString'
  :description:
  - |-
    Packs the contents of arr into a binary sequence according to the
    directives in aTemplateString (see the table below) Directives
    “A,” “a,” and “Z” may be followed by a count, which gives the width of the
    resulting field. The remaining directives also may take a count, indicating
    the number of array elements to convert. If the count is an asterisk
    (“*”), all remaining array elements will be converted. Any of
    the directives “sSiIlL” may be followed by an underscore
    (“_”) or exclamation mark (“!”) to use the
    underlying platform’s native size for the specified type; otherwise, they
    use a platform-independent size. Spaces are ignored in the template string.
    See also String#unpack.
  - |-
    If aBufferString is specified and its capacity is enough,
    pack uses it as the buffer and returns it. When the offset is
    specified by the beginning of aTemplateString, the result is
    filled after the offset. If original contents of aBufferString
    exists and it’s longer than the offset, the rest of offsetOfBuffer
    are overwritten by the result. If it’s shorter, the gap is filled with
    “\0”.
  - |-
    Note that “buffer:” option does not guarantee not to allocate memory in
    pack.  If the capacity of aBufferString is not
    enough, pack allocates memory.
  - Directives for pack.
  :examples: |
    a = [ "a", "b", "c" ]
    n = [ 65, 66, 67 ]
    a.pack("A3A3A3")   #=> "a  b  c  "
    a.pack("a3a3a3")   #=> "a\000\000b\000\000c\000\000"
    n.pack("ccc")      #=> "ABC"
- :id: 59
  :callseqs:
  - permutation { |p| block }          → ary
  - permutation                        → Enumerator
  - permutation(n) { |p| block }       → ary
  - permutation(n)                     → Enumerator
  :description:
  - |-
    When invoked with a block, yield all permutations of length n
    of the elements of the array, then return the array itself.
  - If n is not specified, yield all permutations of all elements.
  - |-
    The implementation makes no guarantees about the order in which the
    permutations are yielded.
  - |-
    If no block is given, an Enumerator is
    returned instead.
  - 'Examples:'
  :examples: |
    a = [1, 2, 3]
    a.permutation.to_a    #=> [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
    a.permutation(1).to_a #=> [[1],[2],[3]]
    a.permutation(2).to_a #=> [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]
    a.permutation(3).to_a #=> [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
    a.permutation(0).to_a #=> [[]] # one permutation of length 0
    a.permutation(4).to_a #=> []   # no permutations of length 4
- :id: 60
  :callseqs:
  - pop    → obj or nil
  - pop(n) → new_ary
  :description:
  - |-
    Removes the last element from self and returns it, or
    nil if the array is empty.
  - |-
    If a number n is given, returns an array of the last
    n elements (or less) just like array.slice!(-n,
    n) does. See also #push for
    the opposite effect.
  :examples: |
    a = [ "a", "b", "c", "d" ]
    a.pop     #=> "d"
    a.pop(2)  #=> ["b", "c"]
    a         #=> ["a"]
- :id: 61
  :callseqs:
  - prepend(*args)
  :description: []
  :examples: ''
- :id: 62
  :callseqs:
  - product(other_ary, ...)                → new_ary
  - product(other_ary, ...) { |p| block }  → ary
  :description:
  - Returns an array of all combinations of elements from all arrays.
  - |-
    The length of the returned array is the product of the length of
    self and the argument arrays.
  - |-
    If given a block, product will
    yield all combinations and return self instead.
  :examples: |
    [1,2,3].product([4,5])     #=> [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]]
    [1,2].product([1,2])       #=> [[1,1],[1,2],[2,1],[2,2]]
    [1,2].product([3,4],[5,6]) #=> [[1,3,5],[1,3,6],[1,4,5],[1,4,6],
                               #     [2,3,5],[2,3,6],[2,4,5],[2,4,6]]
    [1,2].product()            #=> [[1],[2]]
    [1,2].product([])          #=> []
- :id: 63
  :callseqs:
  - push(obj, ... )   → ary
  :description:
  - |-
    Append — Pushes the given object(s) on to the end of this array. This
    expression returns the array itself, so several appends may be chained
    together. See also #pop for the
    opposite effect.
  :examples: |
    a = [ "a", "b", "c" ]
    a.push("d", "e", "f")
            #=> ["a", "b", "c", "d", "e", "f"]
    [1, 2, 3].push(4).push(5)
            #=> [1, 2, 3, 4, 5]
- :id: 64
  :callseqs:
  - rassoc(obj) → element_ary or nil
  :description:
  - Searches through the array whose elements are also arrays.
  - |-
    Compares obj with the second element of each contained array
    using obj.==.
  - Returns the first contained array that matches obj.
  - 'See also #assoc.'
  :examples: |
    a = [ [ 1, "one"], [2, "two"], [3, "three"], ["ii", "two"] ]
    a.rassoc("two")    #=> [2, "two"]
    a.rassoc("four")   #=> nil
- :id: 65
  :callseqs:
  - reject  {|item| block }  → new_ary
  - reject                   → Enumerator
  :description:
  - |-
    Returns a new array containing the items in self for which the
    given block is not true. The ordering of non-rejected elements
    is maintained.
  - 'See also #delete_if'
  - |-
    If no block is given, an Enumerator is
    returned instead.
  :examples: ''
- :id: 66
  :callseqs:
  - reject! { |item| block }  → ary or nil
  - reject!                   → Enumerator
  :description:
  - |-
    Deletes every element of self for which the block evaluates to
    true, if no changes were made returns nil.
  - The array may not be changed instantly every time the block is called.
  - |-
    See also Enumerable#reject
    and #delete_if.
  - |-
    If no block is given, an Enumerator is
    returned instead.
  :examples: ''
- :id: 67
  :callseqs:
  - repeated_combination(n) { |c| block } → ary
  - repeated_combination(n)               → Enumerator
  :description:
  - |-
    When invoked with a block, yields all repeated combinations of length
    n of elements from the array and then returns the array
    itself.
  - |-
    The implementation makes no guarantees about the order in which the
    repeated combinations are yielded.
  - |-
    If no block is given, an Enumerator is
    returned instead.
  - 'Examples:'
  :examples: |
    a = [1, 2, 3]
    a.repeated_combination(1).to_a  #=> [[1], [2], [3]]
    a.repeated_combination(2).to_a  #=> [[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]]
    a.repeated_combination(3).to_a  #=> [[1,1,1],[1,1,2],[1,1,3],[1,2,2],[1,2,3],
                                    #    [1,3,3],[2,2,2],[2,2,3],[2,3,3],[3,3,3]]
    a.repeated_combination(4).to_a  #=> [[1,1,1,1],[1,1,1,2],[1,1,1,3],[1,1,2,2],[1,1,2,3],
                                    #    [1,1,3,3],[1,2,2,2],[1,2,2,3],[1,2,3,3],[1,3,3,3],
                                    #    [2,2,2,2],[2,2,2,3],[2,2,3,3],[2,3,3,3],[3,3,3,3]]
    a.repeated_combination(0).to_a  #=> [[]] # one combination of length 0
- :id: 68
  :callseqs:
  - repeated_permutation(n) { |p| block } → ary
  - repeated_permutation(n)               → Enumerator
  :description:
  - |-
    When invoked with a block, yield all repeated permutations of length
    n of the elements of the array, then return the array itself.
  - |-
    The implementation makes no guarantees about the order in which the
    repeated permutations are yielded.
  - |-
    If no block is given, an Enumerator is
    returned instead.
  - 'Examples:'
  :examples: |
    a = [1, 2]
    a.repeated_permutation(1).to_a  #=> [[1], [2]]
    a.repeated_permutation(2).to_a  #=> [[1,1],[1,2],[2,1],[2,2]]
    a.repeated_permutation(3).to_a  #=> [[1,1,1],[1,1,2],[1,2,1],[1,2,2],
                                    #    [2,1,1],[2,1,2],[2,2,1],[2,2,2]]
    a.repeated_permutation(0).to_a  #=> [[]] # one permutation of length 0
- :id: 69
  :callseqs:
  - replace(other_ary)  → ary
  :description:
  - |-
    Replaces the contents of self with the contents of
    other_ary, truncating or expanding if necessary.
  :examples: |
    a = [ "a", "b", "c", "d", "e" ]
    a.replace([ "x", "y", "z" ])   #=> ["x", "y", "z"]
    a                              #=> ["x", "y", "z"]
- :id: 70
  :callseqs:
  - reverse    → new_ary
  :description:
  - |-
    Returns a new array containing self‘s elements in reverse
    order.
  :examples: |
    [ "a", "b", "c" ].reverse   #=> ["c", "b", "a"]
    [ 1 ].reverse               #=> [1]
- :id: 71
  :callseqs:
  - reverse!   → ary
  :description:
  - Reverses self in place.
  :examples: |
    a = [ "a", "b", "c" ]
    a.reverse!       #=> ["c", "b", "a"]
    a                #=> ["c", "b", "a"]
- :id: 72
  :callseqs:
  - reverse_each { |item| block }  → ary
  - reverse_each                   → Enumerator
  :description:
  - |-
    Same as #each, but traverses
    self in reverse order.
  - 'produces:'
  :examples: |
    a = [ "a", "b", "c" ]
    a.reverse_each {|x| print x, " " }
    c b a
- :id: 73
  :callseqs:
  - rindex(obj)             →  int or nil
  - rindex { |item| block } →  int or nil
  - rindex                  →  Enumerator
  :description:
  - |-
    Returns the index of the last object in self
    == to obj.
  - |-
    If a block is given instead of an argument, returns the index of
    the first object for which the block returns true, starting
    from the last object.
  - Returns nil if no match is found.
  - 'See also #index.'
  - If neither block nor argument is given, an Enumerator is returned instead.
  :examples: |
    a = [ "a", "b", "b", "b", "c" ]
    a.rindex("b")             #=> 3
    a.rindex("z")             #=> nil
    a.rindex { |x| x == "b" } #=> 3
- :id: 74
  :callseqs:
  - rotate(count=1)    → new_ary
  :description:
  - |-
    Returns a new array by rotating self so that the element at
    count is the first element of the new array.
  - |-
    If count is negative then it rotates in the opposite
    direction, starting from the end of self where -1
    is the last element.
  :examples: |
    a = [ "a", "b", "c", "d" ]
    a.rotate         #=> ["b", "c", "d", "a"]
    a                #=> ["a", "b", "c", "d"]
    a.rotate(2)      #=> ["c", "d", "a", "b"]
    a.rotate(-3)     #=> ["b", "c", "d", "a"]
- :id: 75
  :callseqs:
  - rotate!(count=1)   → ary
  :description:
  - |-
    Rotates self in place so that the element at
    count comes first, and returns self.
  - |-
    If count is negative then it rotates in the opposite
    direction, starting from the end of the array where -1 is the
    last element.
  :examples: |
    a = [ "a", "b", "c", "d" ]
    a.rotate!        #=> ["b", "c", "d", "a"]
    a                #=> ["b", "c", "d", "a"]
    a.rotate!(2)     #=> ["d", "a", "b", "c"]
    a.rotate!(-3)    #=> ["a", "b", "c", "d"]
- :id: 76
  :callseqs:
  - sample                  → obj
  - 'sample(random: rng)     → obj'
  - sample(n)               → new_ary
  - 'sample(n, random: rng)  → new_ary'
  :description:
  - Choose a random element or n random elements from the array.
  - |-
    The elements are chosen by using random and unique indices into the array
    in order to ensure that an element doesn’t repeat itself unless the array
    already contained duplicate elements.
  - |-
    If the array is empty the first form returns nil and the
    second form returns an empty array.
  - |-
    The optional rng argument will be used as the random number
    generator.
  :examples: |
    a = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
    a.sample         #=> 7
    a.sample(4)      #=> [6, 4, 2, 5]
- :id: 77
  :callseqs:
  - select { |item| block } → new_ary
  - select                  → Enumerator
  :description:
  - |-
    Returns a new array containing all elements of ary for which
    the given block returns a true value.
  - |-
    If no block is given, an Enumerator is
    returned instead.
  - See also Enumerable#select.
  :examples: |
    [1,2,3,4,5].select { |num|  num.even?  }   #=> [2, 4]

    a = %w{ a b c d e f }
    a.select { |v| v =~ /[aeiou]/ }  #=> ["a", "e"]
- :id: 78
  :callseqs:
  - select!  {|item| block } → ary or nil
  - select!                  → Enumerator
  :description:
  - |-
    Invokes the given block passing in successive elements from
    self, deleting elements for which the block returns a
    false value.
  - The array may not be changed instantly every time the block is called.
  - |-
    If changes were made, it will return self, otherwise it
    returns nil.
  - 'See also #keep_if'
  - |-
    If no block is given, an Enumerator is
    returned instead.
  :examples: ''
- :id: 79
  :callseqs:
  - shift    → obj or nil
  - shift(n) → new_ary
  :description:
  - |-
    Removes the first element of self and returns it (shifting all
    other elements down by one). Returns nil if the array is
    empty.
  - |-
    If a number n is given, returns an array of the first
    n elements (or less) just like array.slice!(0, n)
    does. With ary containing only the remainder elements, not
    including what was shifted to new_ary. See also #unshift for the opposite effect.
  :examples: |
    args = [ "-m", "-q", "filename" ]
    args.shift     #=> "-m"
    args           #=> ["-q", "filename"]

    args = [ "-m", "-q", "filename" ]
    args.shift(2)  #=> ["-m", "-q"]
    args           #=> ["filename"]
- :id: 80
  :callseqs:
  - shuffle              → new_ary
  - 'shuffle(random: rng) → new_ary'
  :description:
  - Returns a new array with elements of self shuffled.
  - |-
    The optional rng argument will be used as the random number
    generator.
  :examples: |
    a = [ 1, 2, 3 ]           #=> [1, 2, 3]
    a.shuffle                 #=> [2, 3, 1]
    a                         #=> [1, 2, 3]
    a.shuffle(random: Random.new(1))  #=> [1, 3, 2]
- :id: 81
  :callseqs:
  - shuffle!              → ary
  - 'shuffle!(random: rng) → ary'
  :description:
  - Shuffles elements in self in place.
  - |-
    The optional rng argument will be used as the random number
    generator.
  :examples: |
    a = [ 1, 2, 3 ]           #=> [1, 2, 3]
    a.shuffle!                #=> [2, 3, 1]
    a                         #=> [2, 3, 1]
    a.shuffle!(random: Random.new(1))  #=> [1, 3, 2]
- :id: 82
  :callseqs:
  - size()
  :description: []
  :examples: ''
- :id: 83
  :callseqs:
  - slice(index)          → obj     or nil
  - slice(start, length)  → new_ary or nil
  - slice(range)          → new_ary or nil
  :description:
  - |-
    Element Reference — Returns the element at index, or returns a
    subarray starting at the start index and continuing for
    length elements, or returns a subarray specified by
    range of indices.
  - |-
    Negative indices count backward from the end of the array (-1 is the last
    element).  For start and range cases the starting
    index is just before an element.  Additionally, an empty array is returned
    when the starting index for an element range is at the end of the array.
  - Returns nil if the index (or starting index) are out of range.
  :examples: |
    a = [ "a", "b", "c", "d", "e" ]
    a[2] +  a[0] + a[1]    #=> "cab"
    a[6]                   #=> nil
    a[1, 2]                #=> [ "b", "c" ]
    a[1..3]                #=> [ "b", "c", "d" ]
    a[4..7]                #=> [ "e" ]
    a[6..10]               #=> nil
    a[-3, 3]               #=> [ "c", "d", "e" ]
    # special cases
    a[5]                   #=> nil
    a[6, 1]                #=> nil
    a[5, 1]                #=> []
    a[5..10]               #=> []
- :id: 84
  :callseqs:
  - slice!(index)         → obj or nil
  - slice!(start, length) → new_ary or nil
  - slice!(range)         → new_ary or nil
  :description:
  - |-
    Deletes the element(s) given by an index (optionally up to
    length elements) or by a range.
  - |-
    Returns the deleted object (or objects), or nil if the
    index is out of range.
  :examples: |
    a = [ "a", "b", "c" ]
    a.slice!(1)     #=> "b"
    a               #=> ["a", "c"]
    a.slice!(-1)    #=> "c"
    a               #=> ["a"]
    a.slice!(100)   #=> nil
    a               #=> ["a"]
- :id: 85
  :callseqs:
  - sort                   → new_ary
  - sort { |a, b| block }  → new_ary
  :description:
  - Returns a new array created by sorting self.
  - |-
    Comparisons for the sort will be done using the <=>
    operator or using an optional code block.
  - |-
    The block must implement a comparison between a and
    b and return an integer less than 0 when b
    follows a, 0 when a and
    b are equivalent, or an integer greater than 0 when
    a follows b.
  - |-
    The result is not guaranteed to be stable.  When the comparison of two
    elements returns 0, the order of the elements is
    unpredictable.
  - See also Enumerable#sort_by.
  :examples: |
    a = [ "d", "a", "e", "c", "b" ]
    a.sort                    #=> ["a", "b", "c", "d", "e"]
    a.sort { |x,y| y <=> x }  #=> ["e", "d", "c", "b", "a"]
- :id: 86
  :callseqs:
  - sort!                   → ary
  - sort! { |a, b| block }  → ary
  :description:
  - Sorts self in place.
  - |-
    Comparisons for the sort will be done using the <=>
    operator or using an optional code block.
  - |-
    The block must implement a comparison between a and
    b and return an integer less than 0 when b
    follows a, 0 when a and
    b are equivalent, or an integer greater than 0 when
    a follows b.
  - |-
    The result is not guaranteed to be stable.  When the comparison of two
    elements returns 0, the order of the elements is
    unpredictable.
  - See also Enumerable#sort_by.
  :examples: |
    a = [ "d", "a", "e", "c", "b" ]
    a.sort!                    #=> ["a", "b", "c", "d", "e"]
    a.sort! { |x,y| y <=> x }  #=> ["e", "d", "c", "b", "a"]
- :id: 87
  :callseqs:
  - sort_by! { |obj| block }    → ary
  - sort_by!                    → Enumerator
  :description:
  - |-
    Sorts self in place using a set of keys generated by mapping
    the values in self through the given block.
  - |-
    The result is not guaranteed to be stable.  When two keys are equal, the
    order of the corresponding elements is unpredictable.
  - |-
    If no block is given, an Enumerator is
    returned instead.
  - See also Enumerable#sort_by.
  :examples: ''
- :id: 88
  :callseqs:
  - sum(init=0)                    → number
  - sum(init=0) {|e| expr }        → number
  :description:
  - |-
    Returns the sum of elements. For example, [e1, e2, e3].sum returns init +
    e1 + e2 + e3.
  - If a block is given, the block is applied to each element before addition.
  - If ary is empty, it returns init.
  - The (arithmetic) mean value of an array can be obtained as follows.
  - |-
    This method can be used for non-numeric objects by explicit init
    argument.
  - |-
    However, #join and #flatten is faster than #sum for array of strings and array of
    arrays.
  - |-
    #sum method may not respect method
    redefinition of "+" methods such as Integer#+.
  :examples: |
    [].sum                             #=> 0
    [].sum(0.0)                        #=> 0.0
    [1, 2, 3].sum                      #=> 6
    [3, 5.5].sum                       #=> 8.5
    [2.5, 3.0].sum(0.0) {|e| e * e }   #=> 15.25
    [Object.new].sum                   #=> TypeError
    mean = ary.sum(0.0) / ary.length
    ["a", "b", "c"].sum("")            #=> "abc"
    [[1], [[2]], [3]].sum([])          #=> [1, [2], 3]
    ["a", "b", "c"].join               #=> "abc"
    [[1], [[2]], [3]].flatten(1)       #=> [1, [2], 3]
- :id: 89
  :callseqs:
  - take(n)               → new_ary
  :description:
  - Returns first n elements from the array.
  - If a negative number is given, raises an ArgumentError.
  - 'See also #drop'
  :examples: |
    a = [1, 2, 3, 4, 5, 0]
    a.take(3)             #=> [1, 2, 3]
- :id: 90
  :callseqs:
  - take_while { |obj| block }  → new_ary
  - take_while                  → Enumerator
  :description:
  - |-
    Passes elements to the block until the block returns nil or
    false, then stops iterating and returns an array of all prior
    elements.
  - |-
    If no block is given, an Enumerator is
    returned instead.
  - 'See also #drop_while'
  :examples: |
    a = [1, 2, 3, 4, 5, 0]
    a.take_while { |i| i < 3 }  #=> [1, 2]
- :id: 91
  :callseqs:
  - to_a     → ary
  :description:
  - Returns self.
  - |-
    If called on a subclass of Array, converts the
    receiver to an Array object.
  :examples: ''
- :id: 92
  :callseqs:
  - to_ary → ary
  :description:
  - Returns self.
  :examples: ''
- :id: 93
  :callseqs:
  - to_h     → hash
  :description:
  - |-
    Returns the result of interpreting ary as an array of [key,
    value] pairs.
  :examples: |
    [[:foo, :bar], [1, 2]].to_h
      # => {:foo => :bar, 1 => 2}
- :id: 94
  :callseqs:
  - to_s()
  :description: []
  :examples: ''
- :id: 95
  :callseqs:
  - transpose → new_ary
  :description:
  - |-
    Assumes that self is an array of arrays and transposes the
    rows and columns.
  - If the length of the subarrays don’t match, an IndexError is raised.
  :examples: |
    a = [[1,2], [3,4], [5,6]]
    a.transpose   #=> [[1, 3, 5], [2, 4, 6]]
- :id: 96
  :callseqs:
  - uniq                → new_ary
  - uniq { |item| ... } → new_ary
  :description:
  - Returns a new array by removing duplicate values in self.
  - |-
    If a block is given, it will use the return value of the block for
    comparison.
  - |-
    It compares values using their hash
    and eql? methods for efficiency.
  - self is traversed in order, and the first occurrence is kept.
  :examples: |
    a = [ "a", "a", "b", "b", "c" ]
    a.uniq   # => ["a", "b", "c"]

    b = [["student","sam"], ["student","george"], ["teacher","matz"]]
    b.uniq { |s| s.first } # => [["student", "sam"], ["teacher", "matz"]]
- :id: 97
  :callseqs:
  - uniq!                → ary or nil
  - uniq! { |item| ... } → ary or nil
  :description:
  - Removes duplicate elements from self.
  - |-
    If a block is given, it will use the return value of the block for
    comparison.
  - |-
    It compares values using their hash
    and eql? methods for efficiency.
  - self is traversed in order, and the first occurrence is kept.
  - |-
    Returns nil if no changes are made (that is, no duplicates are
    found).
  :examples: |
    a = [ "a", "a", "b", "b", "c" ]
    a.uniq!   # => ["a", "b", "c"]

    b = [ "a", "b", "c" ]
    b.uniq!   # => nil

    c = [["student","sam"], ["student","george"], ["teacher","matz"]]
    c.uniq! { |s| s.first } # => [["student", "sam"], ["teacher", "matz"]]
- :id: 98
  :callseqs:
  - unshift(obj, ...)  → ary
  :description:
  - |-
    Prepends objects to the front of self, moving other elements
    upwards. See also #shift for the
    opposite effect.
  :examples: |
    a = [ "b", "c", "d" ]
    a.unshift("a")   #=> ["a", "b", "c", "d"]
    a.unshift(1, 2)  #=> [ 1, 2, "a", "b", "c", "d"]
- :id: 99
  :callseqs:
  - values_at(selector, ...)  → new_ary
  :description:
  - |-
    Returns an array containing the elements in self corresponding
    to the given selector(s).
  - The selectors may be either integer indices or ranges.
  - 'See also #select.'
  :examples: |
    a = %w{ a b c d e f }
    a.values_at(1, 3, 5)          # => ["b", "d", "f"]
    a.values_at(1, 3, 5, 7)       # => ["b", "d", "f", nil]
    a.values_at(-1, -2, -2, -7)   # => ["f", "e", "e", nil]
    a.values_at(4..6, 3...6)      # => ["e", "f", nil, "d", "e", "f"]
- :id: 100
  :callseqs:
  - zip(arg, ...)                  → new_ary
  - zip(arg, ...) { |arr| block }  → nil
  :description:
  - |-
    Converts any arguments to arrays, then merges elements of self
    with corresponding elements from each argument.
  - |-
    This generates a sequence of ary.size n-element
    arrays, where n is one more than the count of arguments.
  - |-
    If the size of any argument is less than the size of the initial array,
    nil values are supplied.
  - |-
    If a block is given, it is invoked for each output array,
    otherwise an array of arrays is returned.
  :examples: |
    a = [ 4, 5, 6 ]
    b = [ 7, 8, 9 ]
    [1, 2, 3].zip(a, b)   #=> [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
    [1, 2].zip(a, b)      #=> [[1, 4, 7], [2, 5, 8]]
    a.zip([1, 2], [8])    #=> [[4, 1, 8], [5, 2, nil], [6, nil, nil]]
- :id: 101
  :callseqs:
  - ary | other_ary     → new_ary
  :description:
  - |-
    Set Union — Returns a new array by joining ary with
    other_ary, excluding any duplicates and preserving the order
    from the given arrays.
  - It compares elements using their hash and eql? methods for efficiency.
  - 'See also #uniq.'
  :examples: |
    [ "a", "b", "c" ] | [ "c", "d", "a" ]    #=> [ "a", "b", "c", "d" ]
    [ "c", "d", "a" ] | [ "a", "b", "c" ]    #=> [ "c", "d", "a", "b" ]
