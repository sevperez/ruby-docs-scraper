---
- :id: 0
  :callseqs:
  - all? [{ |obj| block } ]   → true or false
  :description:
  - |-
    Passes each element of the collection to the given block. The method
    returns true if the block never returns false or
    nil. If the block is not given, Ruby adds an implicit block of
    { |obj| obj } which will cause all? to return true
    when none of the collection members are false or
    nil.
  :examples: |
    %w[ant bear cat].all? { |word| word.length >= 3 } #=> true
    %w[ant bear cat].all? { |word| word.length >= 4 } #=> false
    [nil, true, 99].all?                              #=> false
    [].all?                                           #=> true
- :id: 1
  :callseqs:
  - any? [{ |obj| block }]   → true or false
  :description:
  - |-
    Passes each element of the collection to the given block. The method
    returns true if the block ever returns a value other than
    false or nil. If the block is not given, Ruby
    adds an implicit block of { |obj| obj } that will cause any? to return true
    if at least one of the collection members is not false or
    nil.
  :examples: |
    %w[ant bear cat].any? { |word| word.length >= 3 } #=> true
    %w[ant bear cat].any? { |word| word.length >= 4 } #=> true
    [nil, true, 99].any?                              #=> true
    [].any?                                           #=> false
- :id: 2
  :callseqs:
  - chunk { |elt| ... }                       → an_enumerator
  :description:
  - |-
    Enumerates over the items, chunking them together based on the return value
    of the block.
  - |-
    Consecutive elements which return the same block value are chunked
    together.
  - |-
    For example, consecutive even numbers and odd numbers can be chunked as
    follows.
  - |-
    This method is especially useful for sorted series of elements. The
    following example counts words for each initial letter.
  - 'The following key values have special meaning:'
  - |-
    nil and :_separator specifies that the elements
    should be dropped.
  - |-
    :_alone specifies that the element should be chunked by
    itself.
  - 'Any other symbols that begin with an underscore will raise an error:'
  - |-
    nil and :_separator can be used to ignore some
    elements.
  - |-
    For example, the sequence of hyphens in svn log can be eliminated as
    follows:
  - 'Paragraphs separated by empty lines can be parsed as follows:'
  - |-
    :_alone can be used to force items into their own chunk. For
    example, you can put lines that contain a URL by themselves, and chunk the
    rest of the lines together, like this:
  - If no block is given, an enumerator to `chunk` is returned instead.
  :examples: |
    [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5].chunk { |n|
      n.even?
    }.each { |even, ary|
      p [even, ary]
    }
    #=> [false, [3, 1]]
    #   [true, [4]]
    #   [false, [1, 5, 9]]
    #   [true, [2, 6]]
    #   [false, [5, 3, 5]]
    open("/usr/share/dict/words", "r:iso-8859-1") { |f|
      f.chunk { |line| line.ord }.each { |ch, lines| p [ch.chr, lines.length] }
    }
    #=> ["\n", 1]
    #   ["A", 1327]
    #   ["B", 1372]
    #   ["C", 1507]
    #   ["D", 791]
    #   ...
    items.chunk { |item| :_underscore }
    #=> RuntimeError: symbols beginning with an underscore are reserved
    sep = "-"*72 + "\n"
    IO.popen("svn log README") { |f|
      f.chunk { |line|
        line != sep || nil
      }.each { |_, lines|
        pp lines
      }
    }
    #=> ["r20018 | knu | 2008-10-29 13:20:42 +0900 (Wed, 29 Oct 2008) | 2 lines\n",
    #    "\n",
    #    "* README, README.ja: Update the portability section.\n",
    #    "\n"]
    #   ["r16725 | knu | 2008-05-31 23:34:23 +0900 (Sat, 31 May 2008) | 2 lines\n",
    #    "\n",
    #    "* README, README.ja: Add a note about default C flags.\n",
    #    "\n"]
    #   ...
    File.foreach("README").chunk { |line|
      /\A\s*\z/ !~ line || nil
    }.each { |_, lines|
      pp lines
    }
    pattern = /http/
    open(filename) { |f|
      f.chunk { |line| line =~ pattern ? :_alone : true }.each { |key, lines|
        pp lines
      }
    }
- :id: 3
  :callseqs:
  - chunk_while {|elt_before, elt_after| bool } → an_enumerator
  :description:
  - |-
    Creates an enumerator for each chunked elements. The beginnings of chunks
    are defined by the block.
  - |-
    This method split each chunk using adjacent elements, elt_before
    and elt_after, in the receiver enumerator. This method split
    chunks between elt_before and elt_after where the block
    returns false.
  - The block is called the length of the receiver enumerator minus one.
  - |-
    The result enumerator yields the chunked elements as an array. So
    each method can be called as follows:
  - |-
    Other methods of the Enumerator class and Enumerable module, such as to_a,
    map, etc., are also usable.
  - 'For example, one-by-one increasing subsequence can be chunked as follows:'
  - 'Increasing (non-decreasing) subsequence can be chunked as follows:'
  - |-
    Adjacent evens and odds can be chunked as follows: (Enumerable#chunk is
    another way to do it.)
  - |-
    #slice_when does the
    same, except splitting when the block returns true instead of
    false.
  :examples: |
    a = [1,2,4,9,10,11,12,15,16,19,20,21]
    b = a.chunk_while {|i, j| i+1 == j }
    p b.to_a #=> [[1, 2], [4], [9, 10, 11, 12], [15, 16], [19, 20, 21]]
    c = b.map {|a| a.length < 3 ? a : "#{a.first}-#{a.last}" }
    p c #=> [[1, 2], [4], "9-12", [15, 16], "19-21"]
    d = c.join(",")
    p d #=> "1,2,4,9-12,15,16,19-21"
    a = [0, 9, 2, 2, 3, 2, 7, 5, 9, 5]
    p a.chunk_while {|i, j| i <= j }.to_a
    #=> [[0, 9], [2, 2, 3], [2, 7], [5, 9], [5]]
    a = [7, 5, 9, 2, 0, 7, 9, 4, 2, 0]
    p a.chunk_while {|i, j| i.even? == j.even? }.to_a
    #=> [[7, 5, 9], [2, 0], [7, 9], [4, 2, 0]]
- :id: 4
  :callseqs:
  - collect { |obj| block } → array
  - collect                 → an_enumerator
  :description:
  - |-
    Returns a new array with the results of running block once for
    every element in enum.
  - If no block is given, an enumerator is returned instead.
  :examples: |
    (1..4).map { |i| i*i }      #=> [1, 4, 9, 16]
    (1..4).collect { "cat"  }   #=> ["cat", "cat", "cat", "cat"]
- :id: 5
  :callseqs:
  - collect_concat { |obj| block } → array
  - collect_concat                 → an_enumerator
  :description:
  - |-
    Returns a new array with the concatenated results of running block
    once for every element in enum.
  - If no block is given, an enumerator is returned instead.
  :examples: |
    [1, 2, 3, 4].flat_map { |e| [e, -e] } #=> [1, -1, 2, -2, 3, -3, 4, -4]
    [[1, 2], [3, 4]].flat_map { |e| e + [100] } #=> [1, 2, 100, 3, 4, 100]
- :id: 6
  :callseqs:
  - count                 → int
  - count(item)           → int
  - count { |obj| block } → int
  :description:
  - |-
    Returns the number of items in enum through enumeration. If an
    argument is given, the number of items in enum that are equal
    to item are counted.  If a block is given, it counts the
    number of elements yielding a true value.
  :examples: |
    ary = [1, 2, 4, 2]
    ary.count               #=> 4
    ary.count(2)            #=> 2
    ary.count{ |x| x%2==0 } #=> 3
- :id: 7
  :callseqs:
  - cycle(n=nil) { |obj| block }  →  nil
  - cycle(n=nil)                  →  an_enumerator
  :description:
  - "Calls block for each element of enum repeatedly\nn times or forever if none or
    nil is given.  If a\nnon-positive number is given or the collection is empty,
    does nothing. \nReturns nil if the loop has finished without getting\ninterrupted."
  - |-
    #cycle saves elements in an
    internal array so changes to enum after the first pass have no
    effect.
  - If no block is given, an enumerator is returned instead.
  :examples: |
    a = ["a", "b", "c"]
    a.cycle { |x| puts x }  # print, a, b, c, a, b, c,.. forever.
    a.cycle(2) { |x| puts x }  # print, a, b, c, a, b, c.
- :id: 8
  :callseqs:
  - detect(ifnone = nil) { |obj| block } → obj or nil
  - detect(ifnone = nil)                 → an_enumerator
  :description:
  - |-
    Passes each entry in enum to block. Returns the first for
    which block is not false.  If no object matches, calls
    ifnone and returns its result when it is specified, or returns
    nil otherwise.
  - If no block is given, an enumerator is returned instead.
  :examples: ''
- :id: 9
  :callseqs:
  - drop(n)               → array
  :description:
  - |-
    Drops first n elements from enum, and returns rest elements in an
    array.
  :examples: |
    a = [1, 2, 3, 4, 5, 0]
    a.drop(3)             #=> [4, 5, 0]
- :id: 10
  :callseqs:
  - drop_while { |obj| block }  → array
  - drop_while                  → an_enumerator
  :description:
  - |-
    Drops elements up to, but not including, the first element for which the
    block returns nil or false and returns an array
    containing the remaining elements.
  - If no block is given, an enumerator is returned instead.
  :examples: |
    a = [1, 2, 3, 4, 5, 0]
    a.drop_while { |i| i < 3 }   #=> [3, 4, 5, 0]
- :id: 11
  :callseqs:
  - each_cons(n) { ... } →  nil
  - each_cons(n)         →  an_enumerator
  :description:
  - "Iterates the given block for each array of consecutive <n> elements. \nIf no
    block is given, returns an enumerator."
  - 'e.g.:'
  :examples: |
    (1..10).each_cons(3) { |a| p a }
    # outputs below
    [1, 2, 3]
    [2, 3, 4]
    [3, 4, 5]
    [4, 5, 6]
    [5, 6, 7]
    [6, 7, 8]
    [7, 8, 9]
    [8, 9, 10]
- :id: 12
  :callseqs:
  - each_entry { |obj| block }  → enum
  - each_entry                  → an_enumerator
  :description:
  - |-
    Calls block once for each element in self, passing
    that element as a parameter, converting multiple values from yield to an
    array.
  - If no block is given, an enumerator is returned instead.
  - 'produces:'
  :examples: |
    class Foo
      include Enumerable
      def each
        yield 1
        yield 1, 2
        yield
      end
    end
    Foo.new.each_entry{ |o| p o }
    1
    [1, 2]
    nil
- :id: 13
  :callseqs:
  - each_slice(n) { ... }  →  nil
  - each_slice(n)          →  an_enumerator
  :description:
  - |-
    Iterates the given block for each slice of <n> elements.  If no block
    is given, returns an enumerator.
  :examples: |
    (1..10).each_slice(3) { |a| p a }
    # outputs below
    [1, 2, 3]
    [4, 5, 6]
    [7, 8, 9]
    [10]
- :id: 14
  :callseqs:
  - each_with_index(*args) { |obj, i| block } →  enum
  - each_with_index(*args)                    →  an_enumerator
  :description:
  - |-
    Calls block with two arguments, the item and its index, for each
    item in enum.  Given arguments are passed through to each().
  - If no block is given, an enumerator is returned instead.
  :examples: |
    hash = Hash.new
    %w(cat dog wombat).each_with_index { |item, index|
      hash[item] = index
    }
    hash   #=> {"cat"=>0, "dog"=>1, "wombat"=>2}
- :id: 15
  :callseqs:
  - each_with_object(obj) { |(*args), memo_obj| ... }  →  obj
  - each_with_object(obj)                              →  an_enumerator
  :description:
  - |-
    Iterates the given block for each element with an arbitrary object given,
    and returns the initially given object.
  - If no block is given, returns an enumerator.
  :examples: |
    evens = (1..10).each_with_object([]) { |i, a| a << i*2 }
    #=> [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
- :id: 16
  :callseqs:
  - entries(*args)   → array
  :description:
  - Returns an array containing the items in enum.
  :examples: |
    (1..7).to_a                       #=> [1, 2, 3, 4, 5, 6, 7]
    { 'a'=>1, 'b'=>2, 'c'=>3 }.to_a   #=> [["a", 1], ["b", 2], ["c", 3]]

    require 'prime'
    Prime.entries 10                  #=> [2, 3, 5, 7]
- :id: 17
  :callseqs:
  - find(ifnone = nil)   { |obj| block } → obj or nil
  - find(ifnone = nil)                   → an_enumerator
  :description:
  - |-
    Passes each entry in enum to block. Returns the first for
    which block is not false.  If no object matches, calls
    ifnone and returns its result when it is specified, or returns
    nil otherwise.
  - If no block is given, an enumerator is returned instead.
  :examples: ''
- :id: 18
  :callseqs:
  - find_all { |obj| block } → array
  - find_all                 → an_enumerator
  :description:
  - |-
    Returns an array containing all elements of enum for which the
    given block returns a true value.
  - |-
    If no block is given, an Enumerator is
    returned instead.
  - 'See also #reject.'
  :examples: |
    (1..10).find_all { |i|  i % 3 == 0 }   #=> [3, 6, 9]

    [1,2,3,4,5].select { |num|  num.even?  }   #=> [2, 4]
- :id: 19
  :callseqs:
  - find_index(value)          → int or nil
  - find_index { |obj| block } → int or nil
  - find_index                 → an_enumerator
  :description:
  - |-
    Compares each entry in enum with value or passes to
    block.  Returns the index for the first for which the evaluated
    value is non-false.  If no object matches, returns nil
  - If neither block nor argument is given, an enumerator is returned instead.
  :examples: |
    (1..10).find_index  { |i| i % 5 == 0 and i % 7 == 0 }  #=> nil
    (1..100).find_index { |i| i % 5 == 0 and i % 7 == 0 }  #=> 34
    (1..100).find_index(50)                                #=> 49
- :id: 20
  :callseqs:
  - first       →  obj or nil
  - first(n)    →  an_array
  :description:
  - |-
    Returns the first element, or the first n elements, of the
    enumerable. If the enumerable is empty, the first form returns
    nil, and the second form returns an empty array.
  :examples: |
    %w[foo bar baz].first     #=> "foo"
    %w[foo bar baz].first(2)  #=> ["foo", "bar"]
    %w[foo bar baz].first(10) #=> ["foo", "bar", "baz"]
    [].first                  #=> nil
    [].first(10)              #=> []
- :id: 21
  :callseqs:
  - flat_map       { |obj| block } → array
  - flat_map                       → an_enumerator
  :description:
  - |-
    Returns a new array with the concatenated results of running block
    once for every element in enum.
  - If no block is given, an enumerator is returned instead.
  :examples: |
    [1, 2, 3, 4].flat_map { |e| [e, -e] } #=> [1, -1, 2, -2, 3, -3, 4, -4]
    [[1, 2], [3, 4]].flat_map { |e| e + [100] } #=> [1, 2, 100, 3, 4, 100]
- :id: 22
  :callseqs:
  - grep(pattern)                  → array
  - grep(pattern) { |obj| block }  → array
  :description:
  - |-
    Returns an array of every element in enum for which Pattern
    === element. If the optional block is supplied, each
    matching element is passed to it, and the block’s result is stored in the
    output array.
  :examples: |
    (1..100).grep 38..44   #=> [38, 39, 40, 41, 42, 43, 44]
    c = IO.constants
    c.grep(/SEEK/)         #=> [:SEEK_SET, :SEEK_CUR, :SEEK_END]
    res = c.grep(/SEEK/) { |v| IO.const_get(v) }
    res                    #=> [0, 1, 2]
- :id: 23
  :callseqs:
  - grep_v(pattern)                  → array
  - grep_v(pattern) { |obj| block }  → array
  :description:
  - |-
    Inverted version of #grep.
    Returns an array of every element in enum for which not
    Pattern === element.
  :examples: |
    (1..10).grep_v 2..5   #=> [1, 6, 7, 8, 9, 10]
    res =(1..10).grep_v(2..5) { |v| v * 2 }
    res                    #=> [2, 12, 14, 16, 18, 20]
- :id: 24
  :callseqs:
  - group_by { |obj| block } → a_hash
  - group_by                 → an_enumerator
  :description:
  - |-
    Groups the collection by result of the block.  Returns a hash where the
    keys are the evaluated result from the block and the values are arrays of
    elements in the collection that correspond to the key.
  - If no block is given an enumerator is returned.
  :examples: "(1..6).group_by { |i| i%3 }   #=> {0=>[3, 6], 1=>[1, 4], 2=>[2, 5]}\n"
- :id: 25
  :callseqs:
  - include?(obj)     → true or false
  :description:
  - |-
    Returns true if any member of enum equals
    obj. Equality is tested using ==.
  :examples: |
    IO.constants.include? :SEEK_SET          #=> true
    IO.constants.include? :SEEK_NO_FURTHER   #=> false
    IO.constants.member? :SEEK_SET          #=> true
    IO.constants.member? :SEEK_NO_FURTHER   #=> false
- :id: 26
  :callseqs:
  - inject(initial, sym) → obj
  - inject(sym)          → obj
  - inject(initial) { |memo, obj| block }  → obj
  - inject          { |memo, obj| block }  → obj
  :description:
  - |-
    Combines all elements of enum by applying a binary operation,
    specified by a block or a symbol that names a method or operator.
  - |-
    The inject and reduce methods are aliases. There is no
    performance benefit to either.
  - |-
    If you specify a block, then for each element in enum the block is
    passed an accumulator value (memo) and the element. If you specify
    a symbol instead, then each element in the collection will be passed to the
    named method of memo. In either case, the result becomes the new
    value for memo. At the end of the iteration, the final value of
    memo is the return value for the method.
  - |-
    If you do not explicitly specify an initial value for
    memo, then the first element of collection is used as the initial
    value of memo.
  :examples: |
    # Sum some numbers
    (5..10).reduce(:+)                             #=> 45
    # Same using a block and inject
    (5..10).inject { |sum, n| sum + n }            #=> 45
    # Multiply some numbers
    (5..10).reduce(1, :*)                          #=> 151200
    # Same using a block
    (5..10).inject(1) { |product, n| product * n } #=> 151200
    # find the longest word
    longest = %w{ cat sheep bear }.inject do |memo, word|
       memo.length > word.length ? memo : word
    end
    longest                                        #=> "sheep"
- :id: 27
  :callseqs:
  - lazy → lazy_enumerator
  :description:
  - |-
    Returns a lazy enumerator, whose methods map/collect,
    flat_map/collect_concat, select/find_all, reject, grep, #grep_v, zip, take, #take_while, drop, and #drop_while enumerate values
    only on an as-needed basis.  However, if a block is given to zip, values
    are enumerated immediately.
  - 'The following program finds pythagorean triples:'
  :examples: |
    def pythagorean_triples
      (1..Float::INFINITY).lazy.flat_map {|z|
        (1..z).flat_map {|x|
          (x..z).select {|y|
            x**2 + y**2 == z**2
          }.map {|y|
            [x, y, z]
          }
        }
      }
    end
    # show first ten pythagorean triples
    p pythagorean_triples.take(10).force # take is lazy, so force is needed
    p pythagorean_triples.first(10)      # first is eager
    # show pythagorean triples less than 100
    p pythagorean_triples.take_while { |*, z| z < 100 }.force
- :id: 28
  :callseqs:
  - map     { |obj| block } → array
  - map                     → an_enumerator
  :description:
  - |-
    Returns a new array with the results of running block once for
    every element in enum.
  - If no block is given, an enumerator is returned instead.
  :examples: |
    (1..4).map { |i| i*i }      #=> [1, 4, 9, 16]
    (1..4).collect { "cat"  }   #=> ["cat", "cat", "cat", "cat"]
- :id: 29
  :callseqs:
  - max                     → obj
  - max { |a, b| block }    → obj
  - max(n)                  → array
  - max(n) { |a, b| block } → array
  :description:
  - |-
    Returns the object in enum with the maximum value. The first form
    assumes all objects implement Comparable; the second uses the
    block to return a <=> b.
  - |-
    If the n argument is given, maximum n elements
    are returned as an array, sorted in descending order.
  :examples: |
    a = %w(albatross dog horse)
    a.max                                   #=> "horse"
    a.max { |a, b| a.length <=> b.length }  #=> "albatross"
    a = %w[albatross dog horse]
    a.max(2)                                  #=> ["horse", "dog"]
    a.max(2) {|a, b| a.length <=> b.length }  #=> ["albatross", "horse"]
    [5, 1, 3, 4, 2].max(3)                    #=> [5, 4, 3]
- :id: 30
  :callseqs:
  - max_by {|obj| block }      → obj
  - max_by                     → an_enumerator
  - max_by(n) {|obj| block }   → obj
  - max_by(n)                  → an_enumerator
  :description:
  - |-
    Returns the object in enum that gives the maximum value from the
    given block.
  - If no block is given, an enumerator is returned instead.
  - |-
    If the n argument is given, maximum n elements
    are returned as an array. These n elements are sorted by the
    value from the given block, in descending order.
  - |-
    enum.max_by(n) can be used to implement weighted random sampling. Following
    example implements and use Enumerable#wsample.
  :examples: |
    a = %w(albatross dog horse)
    a.max_by { |x| x.length }   #=> "albatross"
    a = %w[albatross dog horse]
    a.max_by(2) {|x| x.length } #=> ["albatross", "horse"]
    module Enumerable
      # weighted random sampling.
      #
      # Pavlos S. Efraimidis, Paul G. Spirakis
      # Weighted random sampling with a reservoir
      # Information Processing Letters
      # Volume 97, Issue 5 (16 March 2006)
      def wsample(n)
        self.max_by(n) {|v| rand ** (1.0/yield(v)) }
      end
    end
    e = (-20..20).to_a*10000
    a = e.wsample(20000) {|x|
      Math.exp(-(x/5.0)**2) # normal distribution
    }
    # a is 20000 samples from e.
    p a.length #=> 20000
    h = a.group_by {|x| x }
    -10.upto(10) {|x| puts "*" * (h[x].length/30.0).to_i if h[x] }
    #=> *
    #   ***
    #   ******
    #   ***********
    #   ******************
    #   *****************************
    #   *****************************************
    #   ****************************************************
    #   ***************************************************************
    #   ********************************************************************
    #   ***********************************************************************
    #   ***********************************************************************
    #   **************************************************************
    #   ****************************************************
    #   ***************************************
    #   ***************************
    #   ******************
    #   ***********
    #   *******
    #   ***
    #   *
- :id: 31
  :callseqs:
  - member?(obj)      → true or false
  :description:
  - |-
    Returns true if any member of enum equals
    obj. Equality is tested using ==.
  :examples: |
    IO.constants.include? :SEEK_SET          #=> true
    IO.constants.include? :SEEK_NO_FURTHER   #=> false
    IO.constants.member? :SEEK_SET          #=> true
    IO.constants.member? :SEEK_NO_FURTHER   #=> false
- :id: 32
  :callseqs:
  - min                     → obj
  - min { |a, b| block }    → obj
  - min(n)                  → array
  - min(n) { |a, b| block } → array
  :description:
  - |-
    Returns the object in enum with the minimum value. The first form
    assumes all objects implement Comparable; the second uses the
    block to return a <=> b.
  - |-
    If the n argument is given, minimum n elements
    are returned as a sorted array.
  :examples: |
    a = %w(albatross dog horse)
    a.min                                   #=> "albatross"
    a.min { |a, b| a.length <=> b.length }  #=> "dog"
    a = %w[albatross dog horse]
    a.min(2)                                  #=> ["albatross", "dog"]
    a.min(2) {|a, b| a.length <=> b.length }  #=> ["dog", "horse"]
    [5, 1, 3, 4, 2].min(3)                    #=> [1, 2, 3]
- :id: 33
  :callseqs:
  - min_by {|obj| block }      → obj
  - min_by                     → an_enumerator
  - min_by(n) {|obj| block }   → array
  - min_by(n)                  → an_enumerator
  :description:
  - |-
    Returns the object in enum that gives the minimum value from the
    given block.
  - If no block is given, an enumerator is returned instead.
  - |-
    If the n argument is given, minimum n elements
    are returned as an array. These n elements are sorted by the
    value from the given block.
  :examples: |
    a = %w(albatross dog horse)
    a.min_by { |x| x.length }   #=> "dog"
    a = %w[albatross dog horse]
    p a.min_by(2) {|x| x.length } #=> ["dog", "horse"]
- :id: 34
  :callseqs:
  - minmax                  → [min, max]
  - minmax { |a, b| block } → [min, max]
  :description:
  - |-
    Returns a two element array which contains the minimum and the maximum
    value in the enumerable.  The first form assumes all objects implement
    Comparable; the second uses the block to return a
    <=> b.
  :examples: |
    a = %w(albatross dog horse)
    a.minmax                                  #=> ["albatross", "horse"]
    a.minmax { |a, b| a.length <=> b.length } #=> ["dog", "albatross"]
- :id: 35
  :callseqs:
  - minmax_by { |obj| block } → [min, max]
  - minmax_by                 → an_enumerator
  :description:
  - |-
    Returns a two element array containing the objects in enum that
    correspond to the minimum and maximum values respectively from the given
    block.
  - If no block is given, an enumerator is returned instead.
  :examples: |
    a = %w(albatross dog horse)
    a.minmax_by { |x| x.length }   #=> ["dog", "albatross"]
- :id: 36
  :callseqs:
  - none? [{ |obj| block }]   → true or false
  :description:
  - |-
    Passes each element of the collection to the given block. The method
    returns true if the block never returns true for
    all elements. If the block is not given, none? will return
    true only if none of the collection members is true.
  :examples: |
    %w{ant bear cat}.none? { |word| word.length == 5 } #=> true
    %w{ant bear cat}.none? { |word| word.length >= 4 } #=> false
    [].none?                                           #=> true
    [nil].none?                                        #=> true
    [nil, false].none?                                 #=> true
    [nil, false, true].none?                           #=> false
- :id: 37
  :callseqs:
  - one? [{ |obj| block }]   → true or false
  :description:
  - |-
    Passes each element of the collection to the given block. The method
    returns true if the block returns true exactly
    once. If the block is not given, one? will return
    true only if exactly one of the collection members is true.
  :examples: |
    %w{ant bear cat}.one? { |word| word.length == 4 }  #=> true
    %w{ant bear cat}.one? { |word| word.length > 4 }   #=> false
    %w{ant bear cat}.one? { |word| word.length < 4 }   #=> false
    [ nil, true, 99 ].one?                             #=> false
    [ nil, true, false ].one?                          #=> true
- :id: 38
  :callseqs:
  - partition { |obj| block } → [ true_array, false_array ]
  - partition                 → an_enumerator
  :description:
  - |-
    Returns two arrays, the first containing the elements of enum for
    which the block evaluates to true, the second containing the rest.
  - If no block is given, an enumerator is returned instead.
  :examples: "(1..6).partition { |v| v.even? }  #=> [[2, 4, 6], [1, 3, 5]]\n"
- :id: 39
  :callseqs:
  - reduce(initial, sym) → obj
  - reduce(sym)          → obj
  - reduce(initial) { |memo, obj| block }  → obj
  - reduce          { |memo, obj| block }  → obj
  :description:
  - |-
    Combines all elements of enum by applying a binary operation,
    specified by a block or a symbol that names a method or operator.
  - |-
    The inject and reduce methods are aliases. There is no
    performance benefit to either.
  - |-
    If you specify a block, then for each element in enum the block is
    passed an accumulator value (memo) and the element. If you specify
    a symbol instead, then each element in the collection will be passed to the
    named method of memo. In either case, the result becomes the new
    value for memo. At the end of the iteration, the final value of
    memo is the return value for the method.
  - |-
    If you do not explicitly specify an initial value for
    memo, then the first element of collection is used as the initial
    value of memo.
  :examples: |
    # Sum some numbers
    (5..10).reduce(:+)                             #=> 45
    # Same using a block and inject
    (5..10).inject { |sum, n| sum + n }            #=> 45
    # Multiply some numbers
    (5..10).reduce(1, :*)                          #=> 151200
    # Same using a block
    (5..10).inject(1) { |product, n| product * n } #=> 151200
    # find the longest word
    longest = %w{ cat sheep bear }.inject do |memo, word|
       memo.length > word.length ? memo : word
    end
    longest                                        #=> "sheep"
- :id: 40
  :callseqs:
  - reject { |obj| block } → array
  - reject                 → an_enumerator
  :description:
  - |-
    Returns an array for all elements of enum for which the given
    block returns false.
  - |-
    If no block is given, an Enumerator is
    returned instead.
  - 'See also #find_all.'
  :examples: |
    (1..10).reject { |i|  i % 3 == 0 }   #=> [1, 2, 4, 5, 7, 8, 10]

    [1, 2, 3, 4, 5].reject { |num| num.even? } #=> [1, 3, 5]
- :id: 41
  :callseqs:
  - reverse_each(*args) { |item| block } →  enum
  - reverse_each(*args)                  →  an_enumerator
  :description:
  - Builds a temporary array and traverses that array in reverse order.
  - If no block is given, an enumerator is returned instead.
  :examples: ''
- :id: 42
  :callseqs:
  - select   { |obj| block } → array
  - select                   → an_enumerator
  :description:
  - |-
    Returns an array containing all elements of enum for which the
    given block returns a true value.
  - |-
    If no block is given, an Enumerator is
    returned instead.
  - 'See also #reject.'
  :examples: |
    (1..10).find_all { |i|  i % 3 == 0 }   #=> [3, 6, 9]

    [1,2,3,4,5].select { |num|  num.even?  }   #=> [2, 4]
- :id: 43
  :callseqs:
  - slice_after(pattern)       → an_enumerator
  - slice_after { |elt| bool } → an_enumerator
  :description:
  - |-
    Creates an enumerator for each chunked elements. The ends of chunks are
    defined by pattern and the block.
  - |-
    If pattern === elt returns true
    or the block returns true for the element, the element is end
    of a chunk.
  - |-
    The === and block is called from the first element to
    the last element of enum.
  - |-
    The result enumerator yields the chunked elements as an array. So
    each method can be called as follows:
  - |-
    Other methods of the Enumerator class and Enumerable module, such as map,
    etc., are also usable.
  - |-
    For example, continuation lines (lines end with backslash) can be
    concatenated as follows:
  :examples: |
    lines = ["foo\n", "bar\\\n", "baz\n", "\n", "qux\n"]
    e = lines.slice_after(/(?<!\)\n\z/)
    p e.to_a
    #=> [["foo\n"], ["bar\\\n", "baz\n"], ["\n"], ["qux\n"]]
    p e.map {|ll| ll[0...-1].map {|l| l.sub(/\\n\z/, "") }.join + ll.last }
    #=>["foo\n", "barbaz\n", "\n", "qux\n"]
- :id: 44
  :callseqs:
  - slice_before(pattern)                             → an_enumerator
  - slice_before { |elt| bool }                       → an_enumerator
  :description:
  - |-
    Creates an enumerator for each chunked elements. The beginnings of chunks
    are defined by pattern and the block.
  - |-
    If pattern === elt returns true
    or the block returns true for the element, the element is
    beginning of a chunk.
  - |-
    The === and block is called from the first element to
    the last element of enum.  The result for the first element is
    ignored.
  - |-
    The result enumerator yields the chunked elements as an array. So
    each method can be called as follows:
  - |-
    Other methods of the Enumerator class and Enumerable module, such as to_a,
    map, etc., are also usable.
  - |-
    For example, iteration over ChangeLog entries can be implemented as
    follows:
  - |-
    “svn proplist -R” produces multiline output for each file. They can be
    chunked as follows:
  - |-
    If the block needs to maintain state over multiple elements, local
    variables can be used. For example, three or more consecutive increasing
    numbers can be squashed as follows (see chunk_while for a
    better way):
  - |-
    However local variables should be used carefully if the result enumerator
    is enumerated twice or more. The local variables should be initialized for
    each enumeration. Enumerator.new
    can be used to do it.
  - |-
    mbox contains series of mails which start with Unix From line. So each mail
    can be extracted by slice before Unix From line.
  :examples: |
    # iterate over ChangeLog entries.
    open("ChangeLog") { |f|
      f.slice_before(/\A\S/).each { |e| pp e }
    }

    # same as above.  block is used instead of pattern argument.
    open("ChangeLog") { |f|
      f.slice_before { |line| /\A\S/ === line }.each { |e| pp e }
    }
    IO.popen([{"LC_ALL"=>"C"}, "svn", "proplist", "-R"]) { |f|
      f.lines.slice_before(/\AProp/).each { |lines| p lines }
    }
    #=> ["Properties on '.':\n", "  svn:ignore\n", "  svk:merge\n"]
    #   ["Properties on 'goruby.c':\n", "  svn:eol-style\n"]
    #   ["Properties on 'complex.c':\n", "  svn:mime-type\n", "  svn:eol-style\n"]
    #   ["Properties on 'regparse.c':\n", "  svn:eol-style\n"]
    #   ...
    a = [0, 2, 3, 4, 6, 7, 9]
    prev = a[0]
    p a.slice_before { |e|
      prev, prev2 = e, prev
      prev2 + 1 != e
    }.map { |es|
      es.length <= 2 ? es.join(",") : "#{es.first}-#{es.last}"
    }.join(",")
    #=> "0,2-4,6,7,9"
    # Word wrapping.  This assumes all characters have same width.
    def wordwrap(words, maxwidth)
      Enumerator.new {|y|
        # cols is initialized in Enumerator.new.
        cols = 0
        words.slice_before { |w|
          cols += 1 if cols != 0
          cols += w.length
          if maxwidth < cols
            cols = w.length
            true
          else
            false
          end
        }.each {|ws| y.yield ws }
      }
    end
    text = (1..20).to_a.join(" ")
    enum = wordwrap(text.split(/\s+/), 10)
    puts "-"*10
    enum.each { |ws| puts ws.join(" ") } # first enumeration.
    puts "-"*10
    enum.each { |ws| puts ws.join(" ") } # second enumeration generates same result as the first.
    puts "-"*10
    #=> ----------
    #   1 2 3 4 5
    #   6 7 8 9 10
    #   11 12 13
    #   14 15 16
    #   17 18 19
    #   20
    #   ----------
    #   1 2 3 4 5
    #   6 7 8 9 10
    #   11 12 13
    #   14 15 16
    #   17 18 19
    #   20
    #   ----------
    # parse mbox
    open("mbox") { |f|
      f.slice_before { |line|
        line.start_with? "From "
      }.each { |mail|
        unix_from = mail.shift
        i = mail.index("\n")
        header = mail[0...i]
        body = mail[(i+1)..-1]
        body.pop if body.last == "\n"
        fields = header.slice_before { |line| !" \t".include?(line[0]) }.to_a
        p unix_from
        pp fields
        pp body
      }
    }

    # split mails in mbox (slice before Unix From line after an empty line)
    open("mbox") { |f|
      emp = true
      f.slice_before { |line|
        prevemp = emp
        emp = line == "\n"
        prevemp && line.start_with?("From ")
      }.each { |mail|
        mail.pop if mail.last == "\n"
        pp mail
      }
    }
- :id: 45
  :callseqs:
  - slice_when {|elt_before, elt_after| bool } → an_enumerator
  :description:
  - |-
    Creates an enumerator for each chunked elements. The beginnings of chunks
    are defined by the block.
  - |-
    This method split each chunk using adjacent elements, elt_before
    and elt_after, in the receiver enumerator. This method split
    chunks between elt_before and elt_after where the block
    returns true.
  - The block is called the length of the receiver enumerator minus one.
  - |-
    The result enumerator yields the chunked elements as an array. So
    each method can be called as follows:
  - |-
    Other methods of the Enumerator class and Enumerable module, such as to_a,
    map, etc., are also usable.
  - 'For example, one-by-one increasing subsequence can be chunked as follows:'
  - 'Near elements (threshold: 6) in sorted array can be chunked as follows:'
  - 'Increasing (non-decreasing) subsequence can be chunked as follows:'
  - |-
    Adjacent evens and odds can be chunked as follows: (Enumerable#chunk is
    another way to do it.)
  - |-
    Paragraphs (non-empty lines with trailing empty lines) can be chunked as
    follows: (See #chunk to ignore
    empty lines.)
  - |-
    #chunk_while does the
    same, except splitting when the block returns false instead of
    true.
  :examples: |
    a = [1,2,4,9,10,11,12,15,16,19,20,21]
    b = a.slice_when {|i, j| i+1 != j }
    p b.to_a #=> [[1, 2], [4], [9, 10, 11, 12], [15, 16], [19, 20, 21]]
    c = b.map {|a| a.length < 3 ? a : "#{a.first}-#{a.last}" }
    p c #=> [[1, 2], [4], "9-12", [15, 16], "19-21"]
    d = c.join(",")
    p d #=> "1,2,4,9-12,15,16,19-21"
    a = [3, 11, 14, 25, 28, 29, 29, 41, 55, 57]
    p a.slice_when {|i, j| 6 < j - i }.to_a
    #=> [[3], [11, 14], [25, 28, 29, 29], [41], [55, 57]]
    a = [0, 9, 2, 2, 3, 2, 7, 5, 9, 5]
    p a.slice_when {|i, j| i > j }.to_a
    #=> [[0, 9], [2, 2, 3], [2, 7], [5, 9], [5]]
    a = [7, 5, 9, 2, 0, 7, 9, 4, 2, 0]
    p a.slice_when {|i, j| i.even? != j.even? }.to_a
    #=> [[7, 5, 9], [2, 0], [7, 9], [4, 2, 0]]
    lines = ["foo\n", "bar\n", "\n", "baz\n", "qux\n"]
    p lines.slice_when {|l1, l2| /\A\s*\z/ =~ l1 && /\S/ =~ l2 }.to_a
    #=> [["foo\n", "bar\n", "\n"], ["baz\n", "qux\n"]]
- :id: 46
  :callseqs:
  - sort                  → array
  - sort { |a, b| block } → array
  :description:
  - Returns an array containing the items in enum sorted.
  - |-
    Comparisons for the sort will be done using the items’ own
    <=> operator or using an optional code block.
  - |-
    The block must implement a comparison between a and
    b and return an integer less than 0 when b
    follows a, 0 when a and
    b are equivalent, or an integer greater than 0 when
    a follows b.
  - |-
    The result is not guaranteed to be stable.  When the comparison of two
    elements returns 0, the order of the elements is
    unpredictable.
  - |-
    See also #sort_by. It
    implements a Schwartzian transform which is useful when key computation or
    comparison is expensive.
  :examples: |
    %w(rhea kea flea).sort           #=> ["flea", "kea", "rhea"]
    (1..10).sort { |a, b| b <=> a }  #=> [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
- :id: 47
  :callseqs:
  - sort_by { |obj| block }   → array
  - sort_by                   → an_enumerator
  :description:
  - |-
    Sorts enum using a set of keys generated by mapping the values in
    enum through the given block.
  - |-
    The result is not guaranteed to be stable.  When two keys are equal, the
    order of the corresponding elements is unpredictable.
  - If no block is given, an enumerator is returned instead.
  - |-
    The current implementation of sort_by generates an array of
    tuples containing the original collection element and the mapped value.
    This makes sort_by fairly expensive when the keysets are
    simple.
  - 'produces:'
  - |-
    However, consider the case where comparing the keys is a non-trivial
    operation. The following code sorts some files on modification time using
    the basic sort method.
  - |-
    This sort is inefficient: it generates two new File objects
    during every comparison. A slightly better technique is to use the
    Kernel#test method to generate the modification times
    directly.
  - |-
    This still generates many unnecessary Time objects. A more
    efficient technique is to cache the sort keys (modification times in this
    case) before the sort. Perl users often call this approach a Schwartzian
    transform, after Randal Schwartz. We construct a temporary array, where
    each element is an array containing our sort key along with the filename.
    We sort this array, and then extract the filename from the result.
  - This is exactly what sort_by does internally.
  :examples: |
    %w{apple pear fig}.sort_by { |word| word.length }
                  #=> ["fig", "pear", "apple"]
    require 'benchmark'

    a = (1..100000).map { rand(100000) }

    Benchmark.bm(10) do |b|
      b.report("Sort")    { a.sort }
      b.report("Sort by") { a.sort_by { |a| a } }
    end
    files = Dir["*"]
    sorted = files.sort { |a, b| File.new(a).mtime <=> File.new(b).mtime }
    sorted   #=> ["mon", "tues", "wed", "thurs"]
    files = Dir["*"]
    sorted = files.sort { |a, b|
      test(?M, a) <=> test(?M, b)
    }
    sorted   #=> ["mon", "tues", "wed", "thurs"]
    sorted = Dir["*"].collect { |f|
       [test(?M, f), f]
    }.sort.collect { |f| f[1] }
    sorted   #=> ["mon", "tues", "wed", "thurs"]
    sorted = Dir["*"].sort_by { |f| test(?M, f) }
    sorted   #=> ["mon", "tues", "wed", "thurs"]
- :id: 48
  :callseqs:
  - sum(init=0)                   → number
  - sum(init=0) {|e| expr }       → number
  :description:
  - Returns the sum of elements in an Enumerable.
  - If a block is given, the block is applied to each element before addition.
  - If enum is empty, it returns init.
  - 'For example:'
  - |-
    This method can be used for non-numeric objects by explicit init
    argument.
  - |-
    #sum method may not respect
    method redefinition of "+" methods such as Integer#+.
  :examples: |
    { 1 => 10, 2 => 20 }.sum {|k, v| k * v }  #=> 50
    (1..10).sum                               #=> 55
    (1..10).sum {|v| v * 2 }                  #=> 110
    [Object.new].each.sum                     #=> TypeError
    { 1 => 10, 2 => 20 }.sum([])                   #=> [1, 10, 2, 20]
    "a\nb\nc".each_line.lazy.map(&:chomp).sum("")  #=> "abc"
- :id: 49
  :callseqs:
  - take(n)               → array
  :description:
  - Returns first n elements from enum.
  :examples: |
    a = [1, 2, 3, 4, 5, 0]
    a.take(3)             #=> [1, 2, 3]
    a.take(30)            #=> [1, 2, 3, 4, 5, 0]
- :id: 50
  :callseqs:
  - take_while { |obj| block } → array
  - take_while                 → an_enumerator
  :description:
  - |-
    Passes elements to the block until the block returns nil or
    false, then stops iterating and returns an array of all prior
    elements.
  - If no block is given, an enumerator is returned instead.
  :examples: |
    a = [1, 2, 3, 4, 5, 0]
    a.take_while { |i| i < 3 }   #=> [1, 2]
- :id: 51
  :callseqs:
  - to_a(*args)      → array
  :description:
  - Returns an array containing the items in enum.
  :examples: |
    (1..7).to_a                       #=> [1, 2, 3, 4, 5, 6, 7]
    { 'a'=>1, 'b'=>2, 'c'=>3 }.to_a   #=> [["a", 1], ["b", 2], ["c", 3]]

    require 'prime'
    Prime.entries 10                  #=> [2, 3, 5, 7]
- :id: 52
  :callseqs:
  - to_h(*args)  → hash
  :description:
  - |-
    Returns the result of interpreting enum as a list of [key,
    value] pairs.
  :examples: ''
- :id: 53
  :callseqs:
  - uniq                → new_ary
  - uniq { |item| ... } → new_ary
  :description:
  - Returns a new array by removing duplicate values in self.
  - See also Array#uniq.
  :examples: ''
- :id: 54
  :callseqs:
  - zip(arg, ...)                  → an_array_of_array
  - zip(arg, ...) { |arr| block }  → nil
  :description:
  - |-
    Takes one element from enum and merges corresponding elements from
    each args.  This generates a sequence of n-element
    arrays, where n is one more than the count of arguments.  The
    length of the resulting sequence will be enum#size.  If the
    size of any argument is less than enum#size, nil
    values are supplied. If a block is given, it is invoked for each output
    array, otherwise an array of arrays is returned.
  :examples: |
    a = [ 4, 5, 6 ]
    b = [ 7, 8, 9 ]

    a.zip(b)                 #=> [[4, 7], [5, 8], [6, 9]]
    [1, 2, 3].zip(a, b)      #=> [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
    [1, 2].zip(a, b)         #=> [[1, 4, 7], [2, 5, 8]]
    a.zip([1, 2], [8])       #=> [[4, 1, 8], [5, 2, nil], [6, nil, nil]]

    c = []
    a.zip(b) { |x, y| c << x + y }  #=> nil
    c                               #=> [11, 13, 15]
