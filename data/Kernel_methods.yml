---
- :id: 0
  :callseqs:
  - Array(arg)    → array
  :description:
  - Returns arg as an Array.
  - |-
    First tries to call to_ary on arg, then
    to_a.
  :examples: 'Array(1..5)   #=> [1, 2, 3, 4, 5]

'
- :id: 1
  :callseqs:
  - Complex(x[, y])  →  numeric
  :description:
  - Returns x+i*y;
  - 'Syntax of string form:'
  - See String#to_c.
  :examples: |
    Complex(1, 2)    #=> (1+2i)
    Complex('1+2i')  #=> (1+2i)
    Complex(nil)     #=> TypeError
    Complex(1, nil)  #=> TypeError
- :id: 2
  :callseqs: []
  :description: []
  :examples: ''
- :id: 3
  :callseqs:
  - Hash(arg)    → hash
  :description:
  - |-
    Converts arg to a Hash by calling
    arg.to_hash. Returns an empty Hash when
    arg is nil or [].
  :examples: |
    Hash([])          #=> {}
    Hash(nil)         #=> {}
    Hash(key: :value) #=> {:key => :value}
    Hash([1, 2, 3])   #=> TypeError
- :id: 4
  :callseqs:
  - Integer(arg, base=0)    → integer
  :description:
  - |-
    Converts arg to an Integer. Numeric types are converted directly (with floating
    point numbers being truncated).  base (0, or between 2 and 36) is
    a base for integer string representation.  If arg is a
    String, when base is omitted or equals zero, radix
    indicators (0, 0b, and 0x) are
    honored. In any case, strings should be strictly conformed to numeric
    representation. This behavior is different from that of
    String#to_i.  Non string values will be converted by first
    trying to_int, then to_i. Passing
    nil raises a TypeError.
  :examples: |
    Integer(123.999)    #=> 123
    Integer("0x1a")     #=> 26
    Integer(Time.new)   #=> 1204973019
    Integer("0930", 10) #=> 930
    Integer("111", 2)   #=> 7
    Integer(nil)        #=> TypeError
- :id: 5
  :callseqs:
  - Rational(x[, y])  →  numeric
  :description:
  - Returns x/y;
  - 'Syntax of string form:'
  - See String#to_r.
  :examples: |
    Rational(1, 2)   #=> (1/2)
    Rational('1/2')  #=> (1/2)
    Rational(nil)    #=> TypeError
    Rational(1, nil) #=> TypeError
- :id: 6
  :callseqs:
  - String(arg)   → string
  :description:
  - Returns arg as a String.
  - |-
    First tries to call its to_str method, then its
    to_s method.
  :examples: |
    String(self)        #=> "main"
    String(self.class)  #=> "Object"
    String(123456)      #=> "123456"
- :id: 7
  :callseqs:
  - __callee__         → symbol
  :description:
  - |-
    Returns the called name of the current method as a Symbol. If called outside of a method, it returns
    nil.
  :examples: ''
- :id: 8
  :callseqs:
  - __dir__         → string
  :description:
  - |-
    Returns the canonicalized absolute path of the directory of the file from
    which this method is called. It means symlinks in the path is resolved. If
    __FILE__ is nil, it returns nil. The
    return value equals to File.dirname(File.realpath(__FILE__)).
  :examples: ''
- :id: 9
  :callseqs:
  - __method__         → symbol
  :description:
  - |-
    Returns the name at the definition of the current method as a Symbol. If called outside of a method, it returns
    nil.
  :examples: ''
- :id: 10
  :callseqs:
  - "`cmd`    → string"
  :description:
  - |-
    Returns the standard output of running cmd in a subshell. The
    built-in syntax %x{...} uses this method. Sets $?
    to the process status.
  :examples: |
    %x`date`                   #=> "Wed Apr  9 08:56:30 CDT 2003\n"
    %x`ls testdir`.split[1]    #=> "main.rb"
    %x`echo oops && exit 99`   #=> "oops\n"
    $?.exitstatus            #=> 99
- :id: 11
  :callseqs:
  - abort
  - Kernel::abort([msg])
  - abort([msg])
  :description:
  - |-
    Terminate execution immediately, effectively by calling
    Kernel.exit(false). If msg is given, it is written to
    STDERR prior to terminating.
  :examples: ''
- :id: 12
  :callseqs:
  - at_exit { block } → proc
  :description:
  - |-
    Converts block to a Proc object (and therefore binds
    it at the point of call) and registers it for execution when the program
    exits. If multiple handlers are registered, they are executed in reverse
    order of registration.
  - 'produces:'
  :examples: |
    def do_at_exit(str1)
      at_exit { print str1 }
    end
    at_exit { puts "cruel world" }
    do_at_exit("goodbye ")
    exit
    goodbye cruel world
- :id: 13
  :callseqs:
  - autoload(module, filename)   → nil
  :description:
  - |-
    Registers filename to be loaded (using
    Kernel::require) the first time that module (which
    may be a String or a symbol) is accessed.
  :examples: 'autoload(:MyModule, "/usr/local/lib/modules/my_module.rb")

'
- :id: 14
  :callseqs:
  - autoload?(name)   → String or nil
  :description:
  - |-
    Returns filename to be loaded if name is registered as
    autoload.
  :examples: |
    autoload(:B, "b")
    autoload?(:B)            #=> "b"
- :id: 15
  :callseqs:
  - binding → a_binding
  :description:
  - |-
    Returns a Binding object, describing the variable and method
    bindings at the point of call. This object can be used when calling
    eval to execute the evaluated command in this environment. See
    also the description of class Binding.
  :examples: |
    def get_binding(param)
      binding
    end
    b = get_binding("hello")
    eval("param", b)   #=> "hello"
- :id: 16
  :callseqs:
  - block_given?   → true or false
  :description:
  - |-
    Returns true if yield would execute a block in
    the current context. The iterator? form is mildly deprecated.
  :examples: |
    def try
      if block_given?
        yield
      else
        "no block"
      end
    end
    try                  #=> "no block"
    try { "hello" }      #=> "hello"
    try do "hello" end   #=> "hello"
- :id: 17
  :callseqs:
  - callcc {|cont| block }   →  obj
  :description:
  - |-
    Generates a Continuation object, which it
    passes to the associated block. You need to require
    'continuation' before using this method. Performing a
    cont.call will cause the callcc to return (as will falling
    through the end of the block). The value returned by the callcc is the value of the block, or
    the value passed to cont.call. See class Continuation for more details. Also see #throw for an alternative mechanism
    for unwinding a call stack.
  :examples: ''
- :id: 18
  :callseqs:
  - caller(start=1, length=nil)  → array or nil
  - caller(range)                → array or nil
  :description:
  - |-
    Returns the current execution stack—an array containing strings in the form
    file:line or file:line: in `method'.
  - |-
    The optional start parameter determines the number of initial
    stack entries to omit from the top of the stack.
  - |-
    A second optional length parameter can be used to limit how
    many entries are returned from the stack.
  - |-
    Returns nil if start is greater than the size of
    current execution stack.
  - |-
    Optionally you can pass a range, which will return an array containing the
    entries within the specified range.
  :examples: |
    def a(skip)
      caller(skip)
    end
    def b(skip)
      a(skip)
    end
    def c(skip)
      b(skip)
    end
    c(0)   #=> ["prog:2:in `a'", "prog:5:in `b'", "prog:8:in `c'", "prog:10:in `<main>'"]
    c(1)   #=> ["prog:5:in `b'", "prog:8:in `c'", "prog:11:in `<main>'"]
    c(2)   #=> ["prog:8:in `c'", "prog:12:in `<main>'"]
    c(3)   #=> ["prog:13:in `<main>'"]
    c(4)   #=> []
    c(5)   #=> nil
- :id: 19
  :callseqs:
  - caller_locations(start=1, length=nil)    → array or nil
  - caller_locations(range)                  → array or nil
  :description:
  - |-
    Returns the current execution stack—an array containing backtrace location
    objects.
  - |-
    See Thread::Backtrace::Location for
    more information.
  - |-
    The optional start parameter determines the number of initial
    stack entries to omit from the top of the stack.
  - |-
    A second optional length parameter can be used to limit how
    many entries are returned from the stack.
  - |-
    Returns nil if start is greater than the size of
    current execution stack.
  - |-
    Optionally you can pass a range, which will return an array containing the
    entries within the specified range.
  :examples: ''
- :id: 20
  :callseqs:
  - catch([tag]) {|tag| block }  → obj
  :description:
  - |-
    catch executes its block. If throw is not called,
    the block executes normally, and catch returns the value of
    the last expression evaluated.
  - |-
    If throw(tag2, val) is called, Ruby searches up its stack for
    a catch block whose tag has the same
    object_id as tag2. When found, the block stops
    executing and returns val (or nil if no second
    argument was given to throw).
  - |-
    When tag is passed as the first argument, catch
    yields it as the parameter of the block.
  - |-
    When no tag is given, catch yields a new unique
    object (as from Object.new) as the block parameter. This
    object can then be used as the argument to throw, and will
    match the correct catch block.
  :examples: |
    catch(1) { 123 }            # => 123
    catch(1) { throw(1, 456) }  # => 456
    catch(1) { throw(1) }       # => nil
    catch(1) {|x| x + 2 }       # => 3
    catch do |obj_A|
      catch do |obj_B|
        throw(obj_B, 123)
        puts "This puts is not reached"
      end

      puts "This puts is displayed"
      456
    end

    # => 456

    catch do |obj_A|
      catch do |obj_B|
        throw(obj_A, 123)
        puts "This puts is still not reached"
      end

      puts "Now this puts is also not reached"
      456
    end

    # => 123
- :id: 21
  :callseqs:
  - chomp            → $_
  - chomp(string)    → $_
  :description:
  - |-
    Equivalent to $_ = $_.chomp(string). See
    String#chomp. Available only when -p/-n command line option
    specified.
  :examples: ''
- :id: 22
  :callseqs:
  - chop   → $_
  :description:
  - |-
    Equivalent to ($_.dup).chop!, except nil is never
    returned. See String#chop!. Available only when -p/-n command
    line option specified.
  :examples: ''
- :id: 23
  :callseqs:
  - eval(string [, binding [, filename [,lineno]]])  → obj
  :description:
  - |-
    Evaluates the Ruby expression(s) in string. If binding is
    given, which must be a Binding object, the evaluation is
    performed in its context. If the optional filename and
    lineno parameters are present, they will be used when reporting
    syntax errors.
  :examples: |
    def get_binding(str)
      return binding
    end
    str = "hello"
    eval "str + ' Fred'"                      #=> "hello Fred"
    eval "str + ' Fred'", get_binding("bye")  #=> "bye Fred"
- :id: 24
  :callseqs:
  - exec([env,] command... [,options])
  :description:
  - |-
    Replaces the current process by running the given external
    command, which can take one of the following forms:
  - command line string which is passed to the standard shell
  - command name and one or more arguments (no shell)
  - command name, argv and zero or more arguments (no shell)
  - |-
    In the first form, the string is taken as a command line that is subject to
    shell expansion before being executed.
  - |-
    The standard shell always means "/bin/sh" on
    Unix-like systems, same as ENV["RUBYSHELL"] (or
    ENV["COMSPEC"] on Windows NT series), and similar.
  - |-
    If the string from the first form (exec("command"))
    follows these simple rules:
  - no meta characters
  - no shell reserved word and no special built-in
  - Ruby invokes the command directly without shell
  - |-
    You can force shell invocation by adding “;” to the string (because “;” is
    a meta character).
  - |-
    Note that this behavior is observable by pid obtained (return value of
    spawn() and IO#pid for IO.popen) is the pid of the invoked
    command, not shell.
  - |-
    In the second form (exec("command1", "arg1",
    ...)), the first is taken as a command name and the rest are passed
    as parameters to command with no shell expansion.
  - |-
    In the third form (exec(["command", "argv0"],
    "arg1", ...)), starting a two-element array at the
    beginning of the command, the first element is the command to be executed,
    and the second argument is used as the argv[0] value, which
    may show up in process listings.
  - |-
    In order to execute the command, one of the exec(2) system
    calls are used, so the running command may inherit some of the environment
    of the original program (including open file descriptors).
  - |-
    This behavior is modified by the given env and
    options parameters. See ::spawn for details.
  - |-
    If the command fails to execute (typically Errno::ENOENT when
    it was not found) a SystemCallError
    exception is raised.
  - |-
    This method modifies process attributes according to given
    options before exec(2) system call. See ::spawn
    for more details about the given options.
  - |-
    The modified attributes may be retained when exec(2) system
    call fails.
  - For example, hard resource limits are not restorable.
  - 'Consider to create a child process using ::spawn or #system if this is not acceptable.'
  :examples: |
    exec "echo *"       # echoes list of files in current directory
    # never get here

    exec "echo", "*"    # echoes an asterisk
    # never get here
- :id: 25
  :callseqs:
  - exit(status=true)
  - Kernel::exit(status=true)
  - Process::exit(status=true)
  :description:
  - |-
    Initiates the termination of the Ruby script by raising the
    SystemExit exception. This exception may be caught. The
    optional parameter is used to return a status code to the invoking
    environment. true and FALSE of status
    means success and failure respectively.  The interpretation of other
    integer values are system dependent.
  - 'produces:'
  - |-
    Just prior to termination, Ruby executes any at_exit functions
    (see Kernel::at_exit) and runs any object finalizers (see ObjectSpace.define_finalizer).
  - 'produces:'
  :examples: |
    begin
      exit
      puts "never get here"
    rescue SystemExit
      puts "rescued a SystemExit exception"
    end
    puts "after begin block"
    at_exit { puts "at_exit function" }
    ObjectSpace.define_finalizer("string",  proc { puts "in finalizer" })
    exit
- :id: 26
  :callseqs:
  - exit!(status=false)
  :description:
  - |-
    Exits the process immediately. No exit handlers are run. status is
    returned to the underlying system as the exit status.
  :examples: 'Process.exit!(true)

'
- :id: 27
  :callseqs:
  - fail
  - fail(string)
  - fail(exception [, string [, array]])
  :description:
  - |-
    With no arguments, raises the exception in $! or raises a
    RuntimeError if $! is nil. With a
    single String argument, raises a RuntimeError
    with the string as a message. Otherwise, the first parameter should be the
    name of an Exception class (or an object that returns an
    Exception object when sent an exception message).
    The optional second parameter sets the message associated with the
    exception, and the third parameter is an array of callback information.
    Exceptions are caught by the rescue clause of
    begin...end blocks.
  :examples: |
    raise "Failed to create socket"
    raise ArgumentError, "No parameters", caller
- :id: 28
  :callseqs:
  - fork  [{ block }]   → integer or nil
  - fork [{ block }]   → integer or nil
  :description:
  - |-
    Creates a subprocess. If a block is specified, that block is run in the
    subprocess, and the subprocess terminates with a status of zero. Otherwise,
    the fork call returns twice, once in the parent, returning the
    process ID of the child, and once in the child, returning nil. The
    child process can exit using Kernel.exit! to avoid running any
    at_exit functions. The parent process should use
    Process.wait to collect the termination statuses of its
    children or use Process.detach to register disinterest in
    their status; otherwise, the operating system may accumulate zombie
    processes.
  - |-
    The thread calling fork is the only thread in the created child process.
    fork doesn’t copy other threads.
  - If fork is not usable, Process.respond_to?(:fork) returns false.
  - |-
    Note that fork(2) is not available on some platforms like Windows and
    NetBSD 4. Therefore you should use spawn() instead of fork().
  :examples: ''
- :id: 29
  :callseqs:
  - format(format_string [, arguments...] )   → string
  :description:
  - |-
    Returns the string resulting from applying format_string to any
    additional arguments.  Within the format string, any characters other than
    format sequences are copied to the result.
  - The syntax of a format sequence is follows.
  - |-
    A format sequence consists of a percent sign, followed by optional flags,
    width, and precision indicators, then terminated with a field type
    character.  The field type controls how the corresponding
    sprintf argument is to be interpreted, while the flags modify
    that interpretation.
  - 'The field type characters are:'
  - 'The flags modifies the behavior of the formats. The flag characters are:'
  - 'Examples of flags:'
  - |-
    The field width is an optional integer, followed optionally by a period and
    a precision.  The width specifies the minimum number of characters that
    will be written to the result for this field.
  - 'Examples of width:'
  - |-
    For numeric fields, the precision controls the number of decimal places
    displayed.  For string fields, the precision determines the maximum number
    of characters to be copied from the string.  (Thus, the format sequence
    %10.10s will always contribute exactly ten characters to the
    result.)
  - 'Examples of precisions:'
  - 'Examples:'
  - |-
    For more complex formatting, Ruby supports a reference by name.
    %<name>s style uses format style, but %{name} style doesn't.
  - 'Examples:'
  :examples: |
    # `+' and space flag specifies the sign of non-negative numbers.
    sprintf("%d", 123)  #=> "123"
    sprintf("%+d", 123) #=> "+123"
    sprintf("% d", 123) #=> " 123"

    # `#' flag for `o' increases number of digits to show `0'.
    # `+' and space flag changes format of negative numbers.
    sprintf("%o", 123)   #=> "173"
    sprintf("%#o", 123)  #=> "0173"
    sprintf("%+o", -123) #=> "-173"
    sprintf("%o", -123)  #=> "..7605"
    sprintf("%#o", -123) #=> "..7605"

    # `#' flag for `x' add a prefix `0x' for non-zero numbers.
    # `+' and space flag disables complements for negative numbers.
    sprintf("%x", 123)   #=> "7b"
    sprintf("%#x", 123)  #=> "0x7b"
    sprintf("%+x", -123) #=> "-7b"
    sprintf("%x", -123)  #=> "..f85"
    sprintf("%#x", -123) #=> "0x..f85"
    sprintf("%#x", 0)    #=> "0"

    # `#' for `X' uses the prefix `0X'.
    sprintf("%X", 123)  #=> "7B"
    sprintf("%#X", 123) #=> "0X7B"

    # `#' flag for `b' add a prefix `0b' for non-zero numbers.
    # `+' and space flag disables complements for negative numbers.
    sprintf("%b", 123)   #=> "1111011"
    sprintf("%#b", 123)  #=> "0b1111011"
    sprintf("%+b", -123) #=> "-1111011"
    sprintf("%b", -123)  #=> "..10000101"
    sprintf("%#b", -123) #=> "0b..10000101"
    sprintf("%#b", 0)    #=> "0"

    # `#' for `B' uses the prefix `0B'.
    sprintf("%B", 123)  #=> "1111011"
    sprintf("%#B", 123) #=> "0B1111011"

    # `#' for `e' forces to show the decimal point.
    sprintf("%.0e", 1)  #=> "1e+00"
    sprintf("%#.0e", 1) #=> "1.e+00"

    # `#' for `f' forces to show the decimal point.
    sprintf("%.0f", 1234)  #=> "1234"
    sprintf("%#.0f", 1234) #=> "1234."

    # `#' for `g' forces to show the decimal point.
    # It also disables stripping lowest zeros.
    sprintf("%g", 123.4)   #=> "123.4"
    sprintf("%#g", 123.4)  #=> "123.400"
    sprintf("%g", 123456)  #=> "123456"
    sprintf("%#g", 123456) #=> "123456."
    # padding is done by spaces,       width=20
    # 0 or radix-1.             <------------------>
    sprintf("%20d", 123)   #=> "                 123"
    sprintf("%+20d", 123)  #=> "                +123"
    sprintf("%020d", 123)  #=> "00000000000000000123"
    sprintf("%+020d", 123) #=> "+0000000000000000123"
    sprintf("% 020d", 123) #=> " 0000000000000000123"
    sprintf("%-20d", 123)  #=> "123                 "
    sprintf("%-+20d", 123) #=> "+123                "
    sprintf("%- 20d", 123) #=> " 123                "
    sprintf("%020x", -123) #=> "..ffffffffffffffff85"
    # precision for `d', 'o', 'x' and 'b' is
    # minimum number of digits               <------>
    sprintf("%20.8d", 123)  #=> "            00000123"
    sprintf("%20.8o", 123)  #=> "            00000173"
    sprintf("%20.8x", 123)  #=> "            0000007b"
    sprintf("%20.8b", 123)  #=> "            01111011"
    sprintf("%20.8d", -123) #=> "           -00000123"
    sprintf("%20.8o", -123) #=> "            ..777605"
    sprintf("%20.8x", -123) #=> "            ..ffff85"
    sprintf("%20.8b", -11)  #=> "            ..110101"

    # "0x" and "0b" for `#x' and `#b' is not counted for
    # precision but "0" for `#o' is counted.  <------>
    sprintf("%#20.8d", 123)  #=> "            00000123"
    sprintf("%#20.8o", 123)  #=> "            00000173"
    sprintf("%#20.8x", 123)  #=> "          0x0000007b"
    sprintf("%#20.8b", 123)  #=> "          0b01111011"
    sprintf("%#20.8d", -123) #=> "           -00000123"
    sprintf("%#20.8o", -123) #=> "            ..777605"
    sprintf("%#20.8x", -123) #=> "          0x..ffff85"
    sprintf("%#20.8b", -11)  #=> "          0b..110101"

    # precision for `e' is number of
    # digits after the decimal point           <------>
    sprintf("%20.8e", 1234.56789) #=> "      1.23456789e+03"

    # precision for `f' is number of
    # digits after the decimal point               <------>
    sprintf("%20.8f", 1234.56789) #=> "       1234.56789000"

    # precision for `g' is number of
    # significant digits                          <------->
    sprintf("%20.8g", 1234.56789) #=> "           1234.5679"

    #                                         <------->
    sprintf("%20.8g", 123456789)  #=> "       1.2345679e+08"

    # precision for `s' is
    # maximum number of characters                    <------>
    sprintf("%20.8s", "string test") #=> "            string t"
    sprintf("%d %04x", 123, 123)               #=> "123 007b"
    sprintf("%08b '%4s'", 123, 123)            #=> "01111011 ' 123'"
    sprintf("%1$*2$s %2$d %1$s", "hello", 8)   #=> "   hello 8 hello"
    sprintf("%1$*2$s %2$d", "hello", -8)       #=> "hello    -8"
    sprintf("%+g:% g:%-g", 1.23, 1.23, 1.23)   #=> "+1.23: 1.23:1.23"
    sprintf("%u", -123)                        #=> "-123"
    sprintf("%<foo>d : %<bar>f", { :foo => 1, :bar => 2 })
      #=> 1 : 2.000000
    sprintf("%{foo}f", { :foo => 1 })
      # => "1f"
- :id: 30
  :callseqs:
  - gets(sep=$/)     → string or nil
  - gets(limit)      → string or nil
  - gets(sep, limit) → string or nil
  :description:
  - |-
    Returns (and assigns to $_) the next line from the list of
    files in ARGV (or $*), or from standard input if
    no files are present on the command line. Returns nil at end
    of file. The optional argument specifies the record separator. The
    separator is included with the contents of each record. A separator of
    nil reads the entire contents, and a zero-length separator
    reads the input one paragraph at a time, where paragraphs are divided by
    two consecutive newlines.  If the first argument is an integer, or optional
    second argument is given, the returning string would not be longer than the
    given value in bytes.  If multiple filenames are present in
    ARGV, gets(nil) will read the contents one file
    at a time.
  - 'produces:'
  - |-
    The style of programming using $_ as an implicit parameter is
    gradually losing favor in the Ruby community.
  :examples: |
    ARGV << "testfile"
    print while gets
- :id: 31
  :callseqs:
  - global_variables    → array
  :description:
  - Returns an array of the names of global variables.
  :examples: 'global_variables.grep /std/   #=> [:$stdin, :$stdout, :$stderr]

'
- :id: 32
  :callseqs:
  - gsub(pattern, replacement)    → $_
  - gsub(pattern) {|...| block }  → $_
  :description:
  - |-
    Equivalent to $_.gsub..., except that $_ will be
    updated if substitution occurs. Available only when -p/-n command line
    option specified.
  :examples: ''
- :id: 33
  :callseqs:
  - iterator?      → true or false
  :description:
  - |-
    Returns true if yield would execute a block in
    the current context. The iterator? form is mildly deprecated.
  :examples: |
    def try
      if block_given?
        yield
      else
        "no block"
      end
    end
    try                  #=> "no block"
    try { "hello" }      #=> "hello"
    try do "hello" end   #=> "hello"
- :id: 34
  :callseqs:
  - lambda { |...| block }  → a_proc
  :description:
  - |-
    Equivalent to Proc.new, except the resulting Proc objects check the number of parameters passed
    when called.
  :examples: ''
- :id: 35
  :callseqs:
  - load(filename, wrap=false)   → true
  :description:
  - |-
    Loads and executes the Ruby program in the file filename. If the
    filename does not resolve to an absolute path, the file is searched for in
    the library directories listed in $:. If the optional
    wrap parameter is true, the loaded script will be
    executed under an anonymous module, protecting the calling program’s global
    namespace. In no circumstance will any local variables in the loaded file
    be propagated to the loading environment.
  :examples: ''
- :id: 36
  :callseqs:
  - local_variables    → array
  :description:
  - Returns the names of the current local variables.
  :examples: |
    fred = 1
    for i in 1..10
       # ...
    end
    local_variables   #=> [:fred, :i]
- :id: 37
  :callseqs:
  - loop { block }
  - loop            → an_enumerator
  :description:
  - Repeatedly executes the block.
  - If no block is given, an enumerator is returned instead.
  - |-
    StopIteration raised in the block breaks
    the loop.  In this case, loop returns the "result" value stored in the
    exception.
  :examples: |
    loop do
      print "Input: "
      line = gets
      break if !line or line =~ /^qQ/
      # ...
    end
    enum = Enumerator.new { |y|
      y << "one"
      y << "two"
      :ok
    }

    result = loop {
      puts enum.next
    } #=> :ok
- :id: 38
  :callseqs:
  - open(path [, mode [, perm]] [, opt])                → io or nil
  - open(path [, mode [, perm]] [, opt]) {|io| block }  → obj
  :description:
  - |-
    Creates an IO object connected to the given stream,
    file, or subprocess.
  - |-
    If path does not start with a pipe character (|),
    treat it as the name of a file to open using the specified mode (defaulting
    to “r”).
  - |-
    The mode is either a string or an integer.  If it is an
    integer, it must be bitwise-or of open(2) flags, such as File::RDWR or
    File::EXCL.  If it is a string, it is either “fmode”, “fmode:ext_enc”, or
    “fmode:ext_enc:int_enc”.
  - |-
    See the documentation of IO.new for full
    documentation of the mode string directives.
  - |-
    If a file is being created, its initial permissions may be set using the
    perm parameter.  See File.new and the open(2) and chmod(2) man
    pages for a description of permissions.
  - |-
    If a block is specified, it will be invoked with the IO object as a parameter, and the IO will be automatically closed when the block
    terminates.  The call returns the value of the block.
  - |-
    If path starts with a pipe character
    ("|"), a subprocess is created, connected to the
    caller by a pair of pipes.  The returned IO object
    may be used to write to the standard input and read from the standard
    output of this subprocess.
  - |-
    If the command following the pipe is a single minus sign
    ("|-"), Ruby forks, and this subprocess is connected
    to the parent.  If the command is not "-", the
    subprocess runs the command.
  - |-
    When the subprocess is Ruby (opened via "|-"), the
    open call returns nil.  If a block is associated
    with the open call, that block will run twice — once in the parent and once
    in the child.
  - |-
    The block parameter will be an IO object in the
    parent and nil in the child. The parent’s IO
    object will be connected to the child’s $stdin and $stdout.  The subprocess
    will be terminated at the end of the block.
  - 'Reading from “testfile”:'
  - 'Produces:'
  - 'Open a subprocess and read its output:'
  - 'Produces:'
  - 'Open a subprocess running the same Ruby program:'
  - 'Produces:'
  - |-
    Open a subprocess using a block to receive the IO
    object:
  - 'Produces:'
  :examples: |
    open("testfile") do |f|
      print f.gets
    end
    This is line one
    cmd = open("|date")
    print cmd.gets
    cmd.close
    f = open("|-", "w+")
    if f.nil?
      puts "in Child"
      exit
    else
      puts "Got: #{f.gets}"
    end
    open "|-" do |f|
      if f then
        # parent process
        puts "Got: #{f.gets}"
      else
        # child process
        puts "in Child"
      end
    end
- :id: 39
  :callseqs:
  - p(obj)              → obj
  - p(obj1, obj2, ...)  → [obj, ...]
  - p()                 → nil
  :description:
  - |-
    For each object, directly writes obj.inspect followed
    by a newline to the program’s standard output.
  - 'produces:'
  :examples: |
    S = Struct.new(:name, :state)
    s = S['dave', 'TX']
    p s
    #<S name="dave", state="TX">
- :id: 40
  :callseqs:
  - print(obj, ...)    → nil
  :description:
  - |-
    Prints each object in turn to $stdout. If the output field
    separator ($,) is not nil, its contents will
    appear between each field. If the output record separator ($\)
    is not nil, it will be appended to the output. If no arguments
    are given, prints $_. Objects that aren’t strings will be
    converted by calling their to_s method.
  - 'produces:'
  :examples: |
    print "cat", [1,2,3], 99, "\n"
    $, = ", "
    $\ = "\n"
    print "cat", [1,2,3], 99
- :id: 41
  :callseqs:
  - printf(io, string [, obj ... ])    → nil
  - printf(string [, obj ... ])        → nil
  :description:
  - 'Equivalent to:'
  - or
  :examples: ''
- :id: 42
  :callseqs:
  - proc   { |...| block }  → a_proc
  :description:
  - Equivalent to Proc.new.
  :examples: ''
- :id: 43
  :callseqs:
  - putc(int)   → int
  :description:
  - 'Equivalent to:'
  - |-
    Refer to the documentation for IO#putc
    for important information regarding multi-byte characters.
  :examples: "$stdout.putc(int)\n"
- :id: 44
  :callseqs:
  - puts(obj, ...)    → nil
  :description:
  - Equivalent to
  :examples: ''
- :id: 45
  :callseqs:
  - raise
  - raise(string)
  - raise(exception [, string [, array]])
  :description:
  - |-
    With no arguments, raises the exception in $! or raises a
    RuntimeError if $! is nil. With a
    single String argument, raises a RuntimeError
    with the string as a message. Otherwise, the first parameter should be the
    name of an Exception class (or an object that returns an
    Exception object when sent an exception message).
    The optional second parameter sets the message associated with the
    exception, and the third parameter is an array of callback information.
    Exceptions are caught by the rescue clause of
    begin...end blocks.
  :examples: |
    raise "Failed to create socket"
    raise ArgumentError, "No parameters", caller
- :id: 46
  :callseqs:
  - rand(max=0)    → number
  :description:
  - |-
    If called without an argument, or if max.to_i.abs == 0, rand
    returns a pseudo-random floating point number between 0.0 and 1.0,
    including 0.0 and excluding 1.0.
  - |-
    When max.abs is greater than or equal to 1, rand
    returns a pseudo-random integer greater than or equal to 0 and less than
    max.to_i.abs.
  - |-
    When max is a Range,
    rand returns a random number where range.member?(number) ==
    true.
  - |-
    Negative or floating point values for max are allowed, but may
    give surprising results.
  - |-
    #srand may be used to ensure that
    sequences of random numbers are reproducible between different runs of a
    program.
  - See also Random#rand.
  :examples: |
    rand        #=> 0.2725926052826416
    rand(100)   #=> 12
    rand(-100) # => 87
    rand(-0.5) # => 0.8130921818028143
    rand(1.9)  # equivalent to rand(1), which is always 0
- :id: 47
  :callseqs:
  - readline(sep=$/)     → string
  - readline(limit)      → string
  - readline(sep, limit) → string
  :description:
  - |-
    Equivalent to Kernel::gets, except readline
    raises EOFError at end of file.
  :examples: ''
- :id: 48
  :callseqs:
  - readlines(sep=$/)     → array
  - readlines(limit)      → array
  - readlines(sep, limit) → array
  :description:
  - |-
    Returns an array containing the lines returned by calling
    Kernel.gets(sep) until the end of file.
  :examples: ''
- :id: 49
  :callseqs:
  - require(name)    → true or false
  :description:
  - |-
    Loads the given name, returning true if
    successful and false if the feature is already loaded.
  - |-
    If the filename does not resolve to an absolute path, it will be searched
    for in the directories listed in $LOAD_PATH ($:).
  - |-
    If the filename has the extension “.rb”, it is loaded as a source file; if
    the extension is “.so”, “.o”, or “.dll”, or the default shared library
    extension on the current platform, Ruby loads the shared library as a Ruby
    extension.  Otherwise, Ruby tries adding “.rb”, “.so”, and so on to the
    name until found.  If the file named cannot be found, a LoadError will be raised.
  - |-
    For Ruby extensions the filename given may use any shared library
    extension.  For example, on Linux the socket extension is “socket.so” and
    require 'socket.dll' will load the socket extension.
  - |-
    The absolute path of the loaded file is added to
    $LOADED_FEATURES ($").  A file will not be
    loaded again if its path already appears in $".  For
    example, require 'a'; require './a' will not load
    a.rb again.
  - |-
    Any constants or globals within the loaded source file will be available in
    the calling program’s global namespace. However, local variables will not
    be propagated to the loading environment.
  :examples: |
    require "my-library.rb"
    require "db-driver"
- :id: 50
  :callseqs:
  - require_relative(string) → true or false
  :description:
  - |-
    Ruby tries to load the library named string relative to the
    requiring file’s path.  If the file’s path cannot be determined a LoadError is raised. If a file is loaded
    true is returned and false otherwise.
  :examples: ''
- :id: 51
  :callseqs:
  - select(read_array [, write_array [, error_array [, timeout]]]) → array or nil
  :description:
  - |-
    Calls select(2) system call. It monitors given arrays of IO
    objects, waits until one or more of IO objects are ready for
    reading, are ready for writing, and have pending exceptions respectively,
    and returns an array that contains arrays of those IO
    objects.  It will return nil if optional timeout
    value is given and no IO object is ready in timeout
    seconds.
  - |-
    IO.select peeks the buffer of IO objects for
    testing readability. If the IO buffer is not empty,
    IO.select immediately notifies readability. This "peek" only
    happens for IO objects. It does not happen for IO-like objects
    such as OpenSSL::SSL::SSLSocket.
  - |-
    The best way to use IO.select is invoking it after nonblocking
    methods such as read_nonblock, write_nonblock,
    etc. The methods raise an exception which is extended by
    IO::WaitReadable or IO::WaitWritable. The modules
    notify how the caller should wait with IO.select. If
    IO::WaitReadable is raised, the caller should wait for
    reading. If IO::WaitWritable is raised, the caller should wait
    for writing.
  - |-
    So, blocking read (readpartial) can be emulated using
    read_nonblock and IO.select as follows:
  - |-
    Especially, the combination of nonblocking methods and
    IO.select is preferred for IO like objects such
    as OpenSSL::SSL::SSLSocket. It has to_io method
    to return underlying IO object. IO.select calls
    to_io to obtain the file descriptor to wait.
  - |-
    This means that readability notified by IO.select doesn’t mean
    readability from OpenSSL::SSL::SSLSocket object.
  - |-
    The most likely situation is that OpenSSL::SSL::SSLSocket
    buffers some data. IO.select doesn’t see the buffer. So
    IO.select can block when
    OpenSSL::SSL::SSLSocket#readpartial doesn’t block.
  - However, several more complicated situations exist.
  - |-
    SSL is a protocol which is sequence of records. The record consists of
    multiple bytes. So, the remote side of SSL sends a partial record,
    IO.select notifies readability but
    OpenSSL::SSL::SSLSocket cannot decrypt a byte and
    OpenSSL::SSL::SSLSocket#readpartial will blocks.
  - |-
    Also, the remote side can request SSL renegotiation which forces the local
    SSL engine to write some data. This means
    OpenSSL::SSL::SSLSocket#readpartial may invoke
    write system call and it can block. In such a situation,
    OpenSSL::SSL::SSLSocket#read_nonblock raises IO::WaitWritable instead of blocking. So,
    the caller should wait for ready for writability as above example.
  - |-
    The combination of nonblocking methods and IO.select is also
    useful for streams such as tty, pipe socket socket when multiple processes
    read from a stream.
  - |-
    Finally, Linux kernel developers don’t guarantee that readability of
    select(2) means readability of following read(2) even for a single process.
    See select(2) manual on GNU/Linux system.
  - |-
    Invoking IO.select before IO#readpartial works
    well as usual. However it is not the best way to use
    IO.select.
  - |-
    The writability notified by select(2) doesn’t show how many bytes writable.
    IO#write method blocks until given whole string is written.
    So, IO#write(two or more bytes) can block after writability is
    notified by IO.select. IO#write_nonblock is
    required to avoid the blocking.
  - |-
    Blocking write (write) can be emulated using
    write_nonblock and IO.select as follows: IO::WaitReadable should also be rescued for
    SSL renegotiation in OpenSSL::SSL::SSLSocket.
  - an array of IO objects that wait until ready for read
  - an array of IO objects that wait until ready for write
  - an array of IO objects that wait for exceptions
  - a numeric value in second
  - 'produces:'
  :examples: |
    begin
      result = io_like.read_nonblock(maxlen)
    rescue IO::WaitReadable
      IO.select([io_like])
      retry
    rescue IO::WaitWritable
      IO.select(nil, [io_like])
      retry
    end
    while 0 < string.bytesize
      begin
        written = io_like.write_nonblock(string)
      rescue IO::WaitReadable
        IO.select([io_like])
        retry
      rescue IO::WaitWritable
        IO.select(nil, [io_like])
        retry
      end
      string = string.byteslice(written..-1)
    end
    rp, wp = IO.pipe
    mesg = "ping "
    100.times {
      # IO.select follows IO#read.  Not the best way to use IO.select.
      rs, ws, = IO.select([rp], [wp])
      if r = rs[0]
        ret = r.read(5)
        print ret
        case ret
        when /ping/
          mesg = "pong\n"
        when /pong/
          mesg = "ping "
        end
      end
      if w = ws[0]
        w.write(mesg)
      end
    }
    ping pong
    ping pong
    ping pong
    (snipped)
    ping
- :id: 52
  :callseqs:
  - set_trace_func(proc)    → proc
  - set_trace_func(nil)     → nil
  :description:
  - |-
    Establishes proc as the handler for tracing, or disables tracing
    if the parameter is nil.
  - 'Note: this method is obsolete, please use TracePoint instead.'
  - 'proc takes up to six parameters:'
  - an event name
  - a filename
  - a line number
  - an object id
  - a binding
  - the name of a class
  - proc is invoked whenever an event occurs.
  - 'Events are:'
  - call a C-language routine
  - return from a C-language routine
  - call a Ruby method
  - start a class or module definition
  - finish a class or module definition
  - execute code on a new line
  - raise an exception
  - return from a Ruby method
  - Tracing is disabled within the context of proc.
  :examples: ''
- :id: 53
  :callseqs:
  - sleep([duration])    → integer
  :description:
  - |-
    Suspends the current thread for duration seconds (which may be any
    number, including a Float with fractional seconds). Returns
    the actual number of seconds slept (rounded), which may be less than that
    asked for if another thread calls Thread#run. Called without
    an argument, sleep() will sleep forever.
  :examples: |
    Time.new    #=> 2008-03-08 19:56:19 +0900
    sleep 1.2   #=> 1
    Time.new    #=> 2008-03-08 19:56:20 +0900
    sleep 1.9   #=> 2
    Time.new    #=> 2008-03-08 19:56:22 +0900
- :id: 54
  :callseqs:
  - spawn([env,] command... [,options])     → pid
  - spawn([env,] command... [,options])     → pid
  :description:
  - spawn executes specified command and return its pid.
  - |-
    This method is similar to #system
    but it doesn’t wait for the command to finish.
  - |-
    The parent process should use Process.wait to collect the
    termination status of its child or use Process.detach to
    register disinterest in their status; otherwise, the operating system may
    accumulate zombie processes.
  - 'spawn has bunch of options to specify process attributes:'
  - |-
    If a hash is given as env, the environment is updated by
    env before exec(2) in the child process. If a
    pair in env has nil as the value, the variable is deleted.
  - |-
    If a hash is given as options, it specifies process group,
    create new process group, resource limit, current directory, umask and
    redirects for the child process. Also, it can be specified to clear
    environment variables.
  - |-
    The :unsetenv_others key in options specifies to
    clear environment variables, other than specified by env.
  - |-
    The :pgroup key in options specifies a process
    group. The corresponding value should be true, zero, a positive integer, or
    nil. true and zero cause the process to be a process leader of a new
    process group. A non-zero positive integer causes the process to join the
    provided process group. The default value, nil, causes the process to
    remain in the same process group.
  - |-
    The :new_pgroup key in options specifies to pass
    CREATE_NEW_PROCESS_GROUP flag to CreateProcessW()
    that is Windows API. This option is only for Windows. true means the new
    process is the root process of the new process group. The new process has
    CTRL+C disabled. This flag is necessary for Process.kill(:SIGINT,
    pid) on the subprocess. :new_pgroup is false by default.
  - |-
    The :rlimit_foo key specifies a resource limit.
    foo should be one of resource types such as core. The
    corresponding value should be an integer or an array which have one or two
    integers: same as cur_limit and max_limit arguments for Process.setrlimit.
  - The :umask key in options specifies the umask.
  - |-
    The :in, :out, :err, an integer, an IO and an array
    key specifies a redirection. The redirection maps a file descriptor in the
    child process.
  - 'For example, stderr can be merged into stdout as follows:'
  - |-
    The hash keys specifies a file descriptor in the child process started by
    spawn. :err, 2 and STDERR specifies the standard error stream
    (stderr).
  - |-
    The hash values specifies a file descriptor in the parent process which
    invokes spawn. :out, 1 and STDOUT specifies the standard
    output stream (stdout).
  - |-
    In the above example, the standard output in the child process is not
    specified. So it is inherited from the parent process.
  - The standard input stream (stdin) can be specified by :in, 0 and STDIN.
  - A filename can be specified as a hash value.
  - |-
    For stdout and stderr (and combination of them), it is opened in write
    mode. Otherwise read mode is used.
  - |-
    For specifying flags and permission of file creation explicitly, an array
    is used instead.
  - |-
    The array specifies a filename, flags and permission. The flags can be a
    string or an integer. If the flags is omitted or nil, File::RDONLY is
    assumed. The permission should be an integer. If the permission is omitted
    or nil, 0644 is assumed.
  - |-
    If an array of IOs and integers are specified as a hash key, all the
    elements are redirected.
  - |-
    Another way to merge multiple file descriptors is [:child, fd]. [:child,
    fd] means the file descriptor in the child process. This is different from
    fd. For example, :err=>:out means redirecting child stderr to parent
    stdout. But :err=>[:child, :out] means redirecting child stderr to child
    stdout. They differ if stdout is redirected in the child process as
    follows.
  - |-
    [:child, :out] can be used to merge stderr into stdout in IO.popen. In this case, IO.popen redirects stdout to a pipe in
    the child process and [:child, :out] refers the redirected stdout.
  - |-
    The :chdir key in options specifies the current
    directory.
  - |-
    spawn closes all non-standard unspecified descriptors by default. The
    “standard” descriptors are 0, 1 and 2. This behavior is specified by
    :close_others option. :close_others doesn’t affect the standard descriptors
    which are closed only if :close is specified explicitly.
  - ":close_others is true by default for spawn and IO.popen."
  - |-
    Note that fds which close-on-exec flag is already set are closed regardless
    of :close_others option.
  - So IO.pipe and spawn can be used as IO.popen.
  - ":close is specified as a hash value to close a fd individually."
  - If a file descriptor need to be inherited, io=>io can be used.
  - It is also possible to exchange file descriptors.
  - |-
    The hash keys specify file descriptors in the child process. The hash
    values specifies file descriptors in the parent process. So the above
    specifies exchanging stdout and stderr. Internally, spawn uses
    an extra file descriptor to resolve such cyclic file descriptor mapping.
  - See Kernel.exec for the standard shell.
  :examples: |
    pid = spawn("tar xf ruby-2.0.0-p195.tar.bz2")
    Process.wait pid

    pid = spawn(RbConfig.ruby, "-eputs'Hello, world!'")
    Process.wait pid
    # set FOO as BAR and unset BAZ.
    pid = spawn({"FOO"=>"BAR", "BAZ"=>nil}, command)
    pid = spawn(command, :unsetenv_others=>true) # no environment variable
    pid = spawn({"FOO"=>"BAR"}, command, :unsetenv_others=>true) # FOO only
    pid = spawn(command, :pgroup=>true) # process leader
    pid = spawn(command, :pgroup=>10) # belongs to the process group 10
    pid = spawn(command, :new_pgroup=>true)  # new process group
    pid = spawn(command, :new_pgroup=>false) # same process group
    cur, max = Process.getrlimit(:CORE)
    pid = spawn(command, :rlimit_core=>[0,max]) # disable core temporary.
    pid = spawn(command, :rlimit_core=>max) # enable core dump
    pid = spawn(command, :rlimit_core=>0) # never dump core.
    pid = spawn(command, :umask=>077)
    pid = spawn(command, :err=>:out)
    pid = spawn(command, 2=>1)
    pid = spawn(command, STDERR=>:out)
    pid = spawn(command, STDERR=>STDOUT)
    pid = spawn(command, :in=>"/dev/null") # read mode
    pid = spawn(command, :out=>"/dev/null") # write mode
    pid = spawn(command, :err=>"log") # write mode
    pid = spawn(command, [:out, :err]=>"/dev/null") # write mode
    pid = spawn(command, 3=>"/dev/null") # read mode
    pid = spawn(command, :in=>["file"]) # read mode is assumed
    pid = spawn(command, :in=>["file", "r"])
    pid = spawn(command, :out=>["log", "w"]) # 0644 assumed
    pid = spawn(command, :out=>["log", "w", 0600])
    pid = spawn(command, :out=>["log", File::WRONLY|File::EXCL|File::CREAT, 0600])
    # stdout and stderr is redirected to log file.
    # The file "log" is opened just once.
    pid = spawn(command, [:out, :err]=>["log", "w"])
    # stdout and stderr is redirected to log file.
    # The file "log" is opened just once.
    pid = spawn(command, :out=>["log", "w"], :err=>[:child, :out])
    io = IO.popen(["sh", "-c", "echo out; echo err >&2", :err=>[:child, :out]])
    p io.read #=> "out\nerr\n"
    pid = spawn(command, :chdir=>"/var/tmp")
    pid = spawn(command, :close_others=>true)  # close 3,4,5,... (default)
    pid = spawn(command, :close_others=>false) # don't close 3,4,5,...
    # similar to r = IO.popen(command)
    r, w = IO.pipe
    pid = spawn(command, :out=>w)   # r, w is closed in the child process.
    w.close
    f = open(foo)
    system(command, f=>:close)        # don't inherit f.
    # valgrind has --log-fd option for log destination.
    # log_w=>log_w indicates log_w.fileno inherits to child process.
    log_r, log_w = IO.pipe
    pid = spawn("valgrind", "--log-fd=#{log_w.fileno}", "echo", "a", log_w=>log_w)
    log_w.close
    p log_r.read
    pid = spawn(command, :out=>:err, :err=>:out)
- :id: 55
  :callseqs:
  - sprintf(format_string [, arguments...] )  → string
  :description:
  - |-
    Returns the string resulting from applying format_string to any
    additional arguments.  Within the format string, any characters other than
    format sequences are copied to the result.
  - The syntax of a format sequence is follows.
  - |-
    A format sequence consists of a percent sign, followed by optional flags,
    width, and precision indicators, then terminated with a field type
    character.  The field type controls how the corresponding
    sprintf argument is to be interpreted, while the flags modify
    that interpretation.
  - 'The field type characters are:'
  - 'The flags modifies the behavior of the formats. The flag characters are:'
  - 'Examples of flags:'
  - |-
    The field width is an optional integer, followed optionally by a period and
    a precision.  The width specifies the minimum number of characters that
    will be written to the result for this field.
  - 'Examples of width:'
  - |-
    For numeric fields, the precision controls the number of decimal places
    displayed.  For string fields, the precision determines the maximum number
    of characters to be copied from the string.  (Thus, the format sequence
    %10.10s will always contribute exactly ten characters to the
    result.)
  - 'Examples of precisions:'
  - 'Examples:'
  - |-
    For more complex formatting, Ruby supports a reference by name.
    %<name>s style uses format style, but %{name} style doesn't.
  - 'Examples:'
  :examples: |
    # `+' and space flag specifies the sign of non-negative numbers.
    sprintf("%d", 123)  #=> "123"
    sprintf("%+d", 123) #=> "+123"
    sprintf("% d", 123) #=> " 123"

    # `#' flag for `o' increases number of digits to show `0'.
    # `+' and space flag changes format of negative numbers.
    sprintf("%o", 123)   #=> "173"
    sprintf("%#o", 123)  #=> "0173"
    sprintf("%+o", -123) #=> "-173"
    sprintf("%o", -123)  #=> "..7605"
    sprintf("%#o", -123) #=> "..7605"

    # `#' flag for `x' add a prefix `0x' for non-zero numbers.
    # `+' and space flag disables complements for negative numbers.
    sprintf("%x", 123)   #=> "7b"
    sprintf("%#x", 123)  #=> "0x7b"
    sprintf("%+x", -123) #=> "-7b"
    sprintf("%x", -123)  #=> "..f85"
    sprintf("%#x", -123) #=> "0x..f85"
    sprintf("%#x", 0)    #=> "0"

    # `#' for `X' uses the prefix `0X'.
    sprintf("%X", 123)  #=> "7B"
    sprintf("%#X", 123) #=> "0X7B"

    # `#' flag for `b' add a prefix `0b' for non-zero numbers.
    # `+' and space flag disables complements for negative numbers.
    sprintf("%b", 123)   #=> "1111011"
    sprintf("%#b", 123)  #=> "0b1111011"
    sprintf("%+b", -123) #=> "-1111011"
    sprintf("%b", -123)  #=> "..10000101"
    sprintf("%#b", -123) #=> "0b..10000101"
    sprintf("%#b", 0)    #=> "0"

    # `#' for `B' uses the prefix `0B'.
    sprintf("%B", 123)  #=> "1111011"
    sprintf("%#B", 123) #=> "0B1111011"

    # `#' for `e' forces to show the decimal point.
    sprintf("%.0e", 1)  #=> "1e+00"
    sprintf("%#.0e", 1) #=> "1.e+00"

    # `#' for `f' forces to show the decimal point.
    sprintf("%.0f", 1234)  #=> "1234"
    sprintf("%#.0f", 1234) #=> "1234."

    # `#' for `g' forces to show the decimal point.
    # It also disables stripping lowest zeros.
    sprintf("%g", 123.4)   #=> "123.4"
    sprintf("%#g", 123.4)  #=> "123.400"
    sprintf("%g", 123456)  #=> "123456"
    sprintf("%#g", 123456) #=> "123456."
    # padding is done by spaces,       width=20
    # 0 or radix-1.             <------------------>
    sprintf("%20d", 123)   #=> "                 123"
    sprintf("%+20d", 123)  #=> "                +123"
    sprintf("%020d", 123)  #=> "00000000000000000123"
    sprintf("%+020d", 123) #=> "+0000000000000000123"
    sprintf("% 020d", 123) #=> " 0000000000000000123"
    sprintf("%-20d", 123)  #=> "123                 "
    sprintf("%-+20d", 123) #=> "+123                "
    sprintf("%- 20d", 123) #=> " 123                "
    sprintf("%020x", -123) #=> "..ffffffffffffffff85"
    # precision for `d', 'o', 'x' and 'b' is
    # minimum number of digits               <------>
    sprintf("%20.8d", 123)  #=> "            00000123"
    sprintf("%20.8o", 123)  #=> "            00000173"
    sprintf("%20.8x", 123)  #=> "            0000007b"
    sprintf("%20.8b", 123)  #=> "            01111011"
    sprintf("%20.8d", -123) #=> "           -00000123"
    sprintf("%20.8o", -123) #=> "            ..777605"
    sprintf("%20.8x", -123) #=> "            ..ffff85"
    sprintf("%20.8b", -11)  #=> "            ..110101"

    # "0x" and "0b" for `#x' and `#b' is not counted for
    # precision but "0" for `#o' is counted.  <------>
    sprintf("%#20.8d", 123)  #=> "            00000123"
    sprintf("%#20.8o", 123)  #=> "            00000173"
    sprintf("%#20.8x", 123)  #=> "          0x0000007b"
    sprintf("%#20.8b", 123)  #=> "          0b01111011"
    sprintf("%#20.8d", -123) #=> "           -00000123"
    sprintf("%#20.8o", -123) #=> "            ..777605"
    sprintf("%#20.8x", -123) #=> "          0x..ffff85"
    sprintf("%#20.8b", -11)  #=> "          0b..110101"

    # precision for `e' is number of
    # digits after the decimal point           <------>
    sprintf("%20.8e", 1234.56789) #=> "      1.23456789e+03"

    # precision for `f' is number of
    # digits after the decimal point               <------>
    sprintf("%20.8f", 1234.56789) #=> "       1234.56789000"

    # precision for `g' is number of
    # significant digits                          <------->
    sprintf("%20.8g", 1234.56789) #=> "           1234.5679"

    #                                         <------->
    sprintf("%20.8g", 123456789)  #=> "       1.2345679e+08"

    # precision for `s' is
    # maximum number of characters                    <------>
    sprintf("%20.8s", "string test") #=> "            string t"
    sprintf("%d %04x", 123, 123)               #=> "123 007b"
    sprintf("%08b '%4s'", 123, 123)            #=> "01111011 ' 123'"
    sprintf("%1$*2$s %2$d %1$s", "hello", 8)   #=> "   hello 8 hello"
    sprintf("%1$*2$s %2$d", "hello", -8)       #=> "hello    -8"
    sprintf("%+g:% g:%-g", 1.23, 1.23, 1.23)   #=> "+1.23: 1.23:1.23"
    sprintf("%u", -123)                        #=> "-123"
    sprintf("%<foo>d : %<bar>f", { :foo => 1, :bar => 2 })
      #=> 1 : 2.000000
    sprintf("%{foo}f", { :foo => 1 })
      # => "1f"
- :id: 56
  :callseqs:
  - srand(number = Random.new_seed) → old_seed
  :description:
  - |-
    Seeds the system pseudo-random number generator, Random::DEFAULT, with
    number.  The previous seed value is returned.
  - |-
    If number is omitted, seeds the generator using a source of
    entropy provided by the operating system, if available (/dev/urandom on
    Unix systems or the RSA cryptographic provider on Windows), which is then
    combined with the time, the process id, and a sequence number.
  - |-
    srand may be used to ensure repeatable sequences of pseudo-random numbers
    between different runs of the program. By setting the seed to a known
    value, programs can be made deterministic during testing.
  :examples: |
    srand 1234               # => 268519324636777531569100071560086917274
    [ rand, rand ]           # => [0.1915194503788923, 0.6221087710398319]
    [ rand(10), rand(1000) ] # => [4, 664]
    srand 1234               # => 1234
    [ rand, rand ]           # => [0.1915194503788923, 0.6221087710398319]
- :id: 57
  :callseqs:
  - sub(pattern, replacement)   → $_
  - sub(pattern) {|...| block } → $_
  :description:
  - |-
    Equivalent to $_.sub(args), except that
    $_ will be updated if substitution occurs. Available only when
    -p/-n command line option specified.
  :examples: ''
- :id: 58
  :callseqs:
  - syscall(num [, args...])   → integer
  :description:
  - |-
    Calls the operating system function identified by num and returns
    the result of the function or raises SystemCallError if it failed.
  - |-
    Arguments for the function can follow num. They must be either
    String objects or Integer objects. A
    String object is passed as a pointer to the byte sequence. An
    Integer object is passed as an integer whose bit size is same
    as a pointer. Up to nine parameters may be passed.
  - |-
    The function identified by num is system dependent. On some Unix
    systems, the numbers may be obtained from a header file called
    syscall.h.
  - 'produces:'
  - |-
    Calling syscall on a platform which does not have any way to
    an arbitrary system function just fails with NotImplementedError.
  - |-
    Note: syscall is essentially unsafe and
    unportable. Feel free to shoot your foot. The DL (Fiddle) library is
    preferred for safer and a bit more portable programming.
  :examples: |
    syscall 4, 1, "hello\n", 6   # '4' is write(2) on our box
    hello
- :id: 59
  :callseqs:
  - system([env,] command... [,options])    → true, false or nil
  :description:
  - |-
    Executes command… in a subshell. command… is one of
    following forms.
  - |-
    system returns true if the command gives zero exit status,
    false for non zero exit status. Returns nil if
    command execution fails. An error status is available in $?.
    The arguments are processed in the same way as for
    Kernel.spawn.
  - |-
    The hash arguments, env and options, are same as exec and
    spawn. See Kernel.spawn for details.
  - 'produces:'
  - See Kernel.exec for the standard shell.
  :examples: |
    system("echo *")
    system("echo", "*")
- :id: 60
  :callseqs:
  - test(cmd, file1 [, file2] ) → obj
  :description:
  - |-
    Uses the character cmd to perform various tests on
    file1 (first table below) or on file1 and
    file2 (second table).
  - 'File tests on a single file:'
  - 'Tests that take two files:'
  :examples: ''
- :id: 61
  :callseqs:
  - throw(tag [, obj])
  :description:
  - |-
    Transfers control to the end of the active catch block waiting
    for tag. Raises UncaughtThrowError if there is no
    catch block for the tag. The optional second
    parameter supplies a return value for the catch block, which
    otherwise defaults to nil. For examples, see
    Kernel::catch.
  :examples: ''
- :id: 62
  :callseqs:
  - trace_var(symbol, cmd )             → nil
  - trace_var(symbol) {|val| block }    → nil
  :description:
  - |-
    Controls tracing of assignments to global variables. The parameter
    symbol identifies the variable (as either a string name or a
    symbol identifier). cmd (which may be a string or a
    Proc object) or block is executed whenever the variable is
    assigned. The block or Proc object receives the variable's new
    value as a parameter. Also see Kernel::untrace_var.
  - 'produces:'
  :examples: |
    trace_var :$_, proc {|v| puts "$_ is now '#{v}'" }
    $_ = "hello"
    $_ = ' there'
- :id: 63
  :callseqs:
  - trap( signal, command ) → obj
  - trap( signal ) {| | block } → obj
  :description:
  - |-
    Specifies the handling of signals. The first parameter is a signal name (a
    string such as “SIGALRM”, “SIGUSR1”, and so on) or a signal number. The
    characters “SIG” may be omitted from the signal name. The command or block
    specifies code to be run when the signal is raised. If the command is the
    string “IGNORE” or “SIG_IGN”, the signal will be ignored. If the command is
    “DEFAULT” or “SIG_DFL”, the Ruby’s default handler will be invoked. If the
    command is “EXIT”, the script will be terminated by the signal. If the
    command is “SYSTEM_DEFAULT”, the operating system’s default handler will be
    invoked. Otherwise, the given command or block will be run. The special
    signal name “EXIT” or signal number zero will be invoked just prior to
    program termination. trap returns the previous handler for the given
    signal.
  - 'produces:'
  :examples: |
    Signal.trap(0, proc { puts "Terminating: #{$$}" })
    Signal.trap("CLD")  { puts "Child died" }
    fork && Process.wait
- :id: 64
  :callseqs:
  - untrace_var(symbol [, cmd] )   → array or nil
  :description:
  - |-
    Removes tracing for the specified command on the given global variable and
    returns nil. If no command is specified, removes all tracing
    for that variable and returns an array containing the commands actually
    removed.
  :examples: ''
- :id: 65
  :callseqs:
  - warn(msg, ...)   → nil
  :description:
  - |-
    If warnings have been disabled (for example with the -W0
    flag), does nothing.  Otherwise, converts each of the messages to strings,
    appends a newline character to the string if the string does not end in a
    newline, and calls Warning.warn with the string.
  :examples: ''
